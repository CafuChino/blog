{"meta":{"title":"Here`s Chino","subtitle":"夜以继日、自强不息","description":"热爱生活热爱开发的杂食动物","author":"Cafu Chino","url":"https://www.cafuchino.cn","root":"/"},"pages":[{"title":"about","date":"2021-04-12T15:12:32.000Z","updated":"2021-04-12T15:15:00.000Z","comments":true,"path":"about/index.html","permalink":"https://www.cafuchino.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-04-12T15:12:42.000Z","updated":"2021-04-12T15:15:12.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.cafuchino.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-12T15:12:34.000Z","updated":"2021-04-12T15:15:20.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.cafuchino.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"再次梳理浏览器缓存机制","slug":"再次梳理浏览器缓存机制","date":"2021-04-20T03:09:37.000Z","updated":"2021-04-20T09:02:04.097Z","comments":true,"path":"2021/04/20/sort-out-the-browser-caching-mechanism-again/","link":"","permalink":"https://www.cafuchino.cn/2021/04/20/sort-out-the-browser-caching-mechanism-again/","excerpt":"本文的主要内容包括： DNS缓存机制，以及相关的优化方案 浏览器缓存(http缓存)的机制和相关的性能优化点","text":"本文的主要内容包括： DNS缓存机制，以及相关的优化方案 浏览器缓存(http缓存)的机制和相关的性能优化点 DNS缓存之所以提及DNS缓存这一看起来与浏览器缓存关联不大的话题，是因为在这几次面试中缓存机制往往伴随着优化一并考察。而DNS往往是最容易遗漏，也是最容易形成首屏性能瓶颈的方面之一。 以某平台的列表页项目为例，在客户端请求阶段，DNS 查询时间大概是 385 ms，而一个请求下来大约是 1233 ms。这还是在强网（WiFi/4G）的情况下，弱网环境下所需要的的时间可能更多。假如能压缩DNS查询的时间，就可以立刻实现强网下秒开。 有dns的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。 DNS查询过程如下: 首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。 如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。 如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。 DNS 之所以会成为前端性能瓶颈点，是因为每进行一次 DNS 查询，都要经历从手机到移动信号塔，再到认证 DNS 服务器的过程。这中间需要很长的时间。但用户是不想等待的。 想要节省时间，一个办法就是让 DNS 查询走缓存。而我们这几个环节能操控的就只有浏览器这一环节，浏览器提供了 DNS 预获取的接口，我们可以在打开浏览器或者 WebView 的同时就进行配置。这样真正请求时，DNS 域名解析可以检查一下浏览器缓存，一旦缓存命中，就不需要去 DNS 服务器查询了。 DNS-prefetch 以上是淘宝网的dns-prefetch策略，DNS预解析在某个页面中包含非常多的域名非常有效，如搜索结果页。遇到网页中的超链接，DNS prefetching从中提取域名并将其解析为IP地址，这些工作在用户浏览网页时，使用最少的CPU和网络在后台进行解析。当用户点击这些已经预解析的域名，可以平均减少200毫秒耗时（假设用户最近还未访问过该域名），更重要的是用户不会遇到DNS解析最坏的情况（往往超过1秒）。 DNS Prefetch 应该尽量的放在网页的前面，推荐放在 &lt;meta charset=&quot;UTF-8&quot;&gt; 后面。具体使用方法如下： 1234&lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot;&gt;&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;www.zhix.net&quot;&gt;&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;api.share.zhix.net&quot;&gt;&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;bdimg.share.zhix.net&quot;&gt; 预解析的实现： 用meta信息来告知浏览器, 当前页面要做DNS预解析:&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt; 在页面header中使用link标签来强制对DNS预解析:&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt; dns-prefetch需慎用，多页面重复DNS预解析会增加重复DNS查询次数。 需要注意的是，虽然使用 DNS Prefetch 能够加快页面的解析速度，但是也不能滥用，因为有开发者指出 禁用DNS 预读取能节省每月100亿的DNS查询 。如果需要禁止隐式的 DNS Prefetch，可以使用以下的标签： 1&lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;off&quot;&gt; 浏览器缓存浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。 强缓存阶段Cache-Control最高优先级的缓存控制！ 这是一个HTTP/1.1中规定的头字段，在请求和响应阶段哦付可以使用。但是缓存指令是单向的，这也就意味着在请求中设置的指令，不一定被包含在响应中。而再次强调：浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。 客户端可以在HTTP请求中使用的标准 Cache-Control 指令。 1234567Cache-Control: max-age&#x3D;&lt;seconds&gt;Cache-Control: max-stale[&#x3D;&lt;seconds&gt;]Cache-Control: min-fresh&#x3D;&lt;seconds&gt;Cache-control: no-cacheCache-control: no-storeCache-control: no-transformCache-control: only-if-cached 服务器可以在响应中使用的标准 Cache-Control 指令。 123456789Cache-control: must-revalidateCache-control: no-cacheCache-control: no-storeCache-control: no-transformCache-control: publicCache-control: privateCache-control: proxy-revalidateCache-Control: max-age&#x3D;&lt;seconds&gt;Cache-control: s-maxage&#x3D;&lt;seconds&gt; 这一字段的具体配置规则如下： 可缓存性public 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有max-age指令或Expires消息头；2. 该响应对应的请求方法是 POST 。） private 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。 no-cache 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。 no-store 缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。 期限max-age= 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。 s-maxage= 覆盖max-age或者Expires头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。 max-stale[=] 表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。 min-fresh= 表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。 还有一些不是很常用的配置，可以参考MDN文档。 示例以相对常用的no-cache为例，这一配置并不能按照字面意思理解。真正的禁止缓存是no-store 指定 no-cache 或 max-age=0 表示客户端可以缓存资源，每次使用缓存资源前都必须重新验证其有效性。这意味着每次都会发起 HTTP 请求，但当缓存内容仍有效时可以跳过 HTTP 响应体的下载。这样既可以保证内容的有效性，又可以保证能获取到最新的内容。 12Cache-Control: no-cacheCache-Control: max-age&#x3D;0 Expiers这是一个HTTP/1.0的字段，定义了缓存到期的绝对时间。同样，我们也可以在html文件里直接使用: 1&lt;meta http-equiv=&quot;expires&quot; content=&quot;Thu, 30 Nov 2017 11:17:26 GMT&quot;&gt; 如果当前时间已经超过了这个时间，就会重新向服务器请求。这一属性也是强缓存阶段的判断指标，但是有一个缺点——这是一个绝对时间，比较的对象是客户端时间。而如果客户端时间被调整，可能导致缓存失效。所以之前的Cache-Control:max-age就可以很好的解决这一问题。如果在max-age期限内，或者Expires时间未到，便会直接使用缓存的资源。 From disk cache 还是 From memory cache?Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。 协商缓存阶段而如果缓存已经过期，是继续使用缓存还是抛弃缓存重新请求呢？之前提到过可以设置Cache-Control: max-age=0，这样不是相当于缓存时即过期么？确实如此，所以此时需要和服务器通讯确定内容是否已更改，如果未更改可以继续使用缓存。这样只耗费了建立连接的时间，仍然节省了下载响应体的时间。 ETag/If-Match/If-None-MatchETag HTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）。 If-Match可以在提交资源的时候用于检查是否未最新版本，以防空中碰撞（基于旧版本的修改覆盖了修改期间产生的新版本） If-None-Match在请求时的值为之前的Etag值，服务器将客户端的ETag（作为If-None-Match字段的值一起发送）与其当前版本的资源的ETag进行比较，如果两个值匹配（即资源未更改），服务器将返回不带任何内容的304未修改状态，告诉客户端缓存版本可用。 Last-Modified/If-Modified-Since/If-Unmodified-Since这三个的作用和Etag组合的类似，Last-Modified用于标识最后一个版本时间，If-Unmodified-Since确定最后一次更改时间以防空中碰撞，If-Modified-Since是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应。 启发式缓存阶段而假如以上所有的缓存期限设置都不存在怎么办？比如： 12345Age:23146Cache-Control: publicDate:Tue, 28 Nov 2017 12:26:41 GMTLast-Modified:Tue, 28 Nov 2017 05:14:02 GMTVary:Accept-Encoding 启发式缓存机制会根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。 这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种默认缓存的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。 各种缓存期限配置的优缺点 缓存头部 优点 缺点 Expires 1. HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用。2. 简单易用，通过绝对时间标识失效时间。 1. 时间为服务器返回的时间，如果本地时间与服务器时间不一致，则可能会出现问题。（如上述我们通过修改本地时间是缓存失效。）2. 存在版本问题，在资源过期之前如果对资源进行修改，客户端都是无法获知的。 Cache-Control 1. HTTP 1.1的内容，以相对时间标识失效时间，解决了Expires服务器和客户端相对时间的问题。2. 支持的指令较多，可以根据需要进行相应的配置。 1. HTTP 1.1 才有的内容，不适用于HTTP 1.0 。2. 与Expires类似，存在版本问题，在资源过期之前如果对资源进行修改，客户端都是无法获知的。 Last-Modified 1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则重新返回资源。 1. 以时刻作为标识，精确到秒，无法识别一秒内进行多次修改的情况。2. 只要资源被修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。 ETag 1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则重新返回资源。2. 可以更加精确的判断资源是否被修改。3. 可以识别一秒内多次修改的情况。 1. 计算ETag值会对性能造成一定消耗。2. 分布式服务器存储的情况下，需要保证计算ETag的算法一致。如果不一致，会导致资源在不同服务器上验证不通过。 缓存控制流程图flowchart TB 浏览器请求 --> A{是否有缓存} A --> |有缓存|B{是否过期} A --> |无缓存|E[向Web服务器请求] B --> |是|C{上一次请求是否有Etag} B --> |否|D[从缓存读取] C --> |是|F[请求头携带If-None-Match] C --> |否|G{上一次请求是否有Last-Modified} G --> |是|H[请求头携带If-Modified-Since] G --> |否|E F --> I{服务器决策是200还是304} H --> I I --> |文档无更新返回304| J[从缓存读取] I --> |文档有更新返回200| K[请求响应+缓存协商] J --> |缓存失效| K D --> L(呈现页面) K --> L J --> L 常见问题1. 问题：请求被缓存，导致新代码未生效 解决方案: 服务端响应添加Cache-Control:no-cache,must-revalidate指令； 修改请求头If-modified-since:0或If-none-match； 修改请求URL，请求URL后加随机数，随机数可以是时间戳，哈希值，比如：http://damonare.cn?a=1234 2. 问题：服务端缓存导致本地代码未更新 解决方案： 合理设置Cache-Control:s-maxage指令； 设置Cache-Control:private指令，防止代理服务器缓存资源； CDN缓存可以使用管理员设置的缓存刷新接口进行刷新； 3. 问题： Cache-Control: max-age=0 和 no-cache有什么不同 回答： max-age=0和no-cache应该是从语气上不同。max-age=0是告诉客户端资源的缓存到期应该向服务器验证缓存的有效性。而no-cache则告诉客户端使用缓存前必须向服务器验证缓存的有效性。 参考资料 https://zhuanlan.zhihu.com/p/33356918 https://www.jianshu.com/p/5b8d61afe52d?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching","categories":[],"tags":[]},{"title":"又双叒叕从头说“事件循环”","slug":"又双叒叕从头说“事件循环”","date":"2021-04-01T07:10:12.000Z","updated":"2021-04-12T15:19:14.000Z","comments":true,"path":"2021/04/01/shuang-啒啕啒說會說-event-loop-from-the-beginning/","link":"","permalink":"https://www.cafuchino.cn/2021/04/01/shuang-%E5%95%92%E5%95%95%E5%95%92%E8%AA%AA%E6%9C%83%E8%AA%AA-event-loop-from-the-beginning/","excerpt":"经历了长达一个月（仍未结束）的春招提前批面试季，大大小小经历了近十次面试。在整理笔记的过程中，我发现了一些“必考点”。“事件循环”便是其中一个，虽然已经就事件循环做了一些准备，但每次回答完都有一种回答的不充分的感觉……所以不知道第多少次的从头梳理事件循环。","text":"经历了长达一个月（仍未结束）的春招提前批面试季，大大小小经历了近十次面试。在整理笔记的过程中，我发现了一些“必考点”。“事件循环”便是其中一个，虽然已经就事件循环做了一些准备，但每次回答完都有一种回答的不充分的感觉……所以不知道第多少次的从头梳理事件循环。 你了解事件循环机制么？面试官们通常都是以这样一个问题展开对事件循环机制的讨论，而我之前只是机械的回答“略有了解”，然后等着面试官做进一步的提问。但是显然面试官不只是想得到一个这样的回答。所以，面试官可能想得到的是一个关于事件循环的“简要描述”或者说下定义的回答。 那么：什么是事件循环？ 单线程机制的JavaScript引擎，为了实现异步机制，循环不断的从”任务队列”中读取事件，整个的这种运行机制称为Event Loop（事件循环）。 其中的考点已经加粗表示—— 为什么JavaScript采用单线程机制？JavaScript在设计之初是作为浏览器脚本语言使用的，其主要用途就是操作DOM。而为了避免多线程对DOM的操作产生冲突（同时对同一节点做不同修改），JavaScript被设计为单线程。 为什么要实现异步机制由于JavaScript是单线程执行，假如遇到耗时的I/O操作，线程不得不停下来灯带操作完成，带来了无谓的效率下降。异步机制可以让主线程继续执行，当某个异步任务可以执行时再进入主线程执行。 事件循环相关概念 执行栈：所有的同步任务都在主线程上执行，形成执行栈。 任务队列：在主进程之外，当主线程空闲(执行栈空)时，会从任务队列获取可执行的任务。 所以对于事件循环，网络上其他的文章中描述： 在JavaScript中通过回调函数在耗时操作执行完成后把相应的结果信息传递给回调函数，通知执行JavaScript代码的线程执行回调 “通知”？如何通知？通过什么通知？“通知”这个词显然是不太准确的，同时“执行回调”这个行为，也并不是“执行耗时操作完成”这一行为直接通讯（或者说通知）所触发的。要想了解事情的问题所在，就不得不仔细了解一下浏览器渲染进程到底有哪些线程。 浏览器渲染进程到底有哪些线程 GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 其中比较关键的就是“事件触发线程”，事件循环主要就是围绕着事件触发线程展开的。 一段代码说基础异步123456789function task()&#123; ajax1(); // 假设是一个执行完会打印1的ajax请求，以下类似 setTimeout(()=&gt;&#123; ajax2() &#125;,1000)&#125;ajax3();task(); 如果ajax请求的时间短到可以忽略，这段代码会如何执行呢？ task函数被定义 ajax3函数被触发，因为是一个ajax请求，所以浏览器新开了一个异步Http请求线程进行请求，主线程继续执行 task函数开始执行，与此同时ajax3操作已经完成了，但是他的回调不会立刻执行，而是产生“状态变更事件”，这一事件触发了事件触发线程，事件触发线程将回调压入“任务队列”。 task执行（还记得吗，这一步其实和3是同时的），ajax1使得浏览器创建了一个异步Http请求线程，主线程继续执行，遇见了定时器，此时浏览器创建定时触发器线程进行计时。 与此同时，ajax1操作已经完成了，进行了类似步骤3的流程 此时执行栈已经空了，因为同步代码已经执行完了。 主进程尝试从任务队列中获取可以执行的任务，它首先获取到的是ajax3的回调，然后是ajax1的回调，所以他会先打印3，再打印1 1秒钟计时完成，定时触发器线程将回调压入任务队列 主线程获取到了任务，将任务进入执行栈 执行ajax2触发了，浏览器新开了一个异步Http请求线程进行请求，之后也是进行了类似步骤3的操作 打印结果应该是312 宏任务和微任务？在事件循环中，我们不可避免的需要接触到宏任务和微任务。即使是我之前的学习中也对这方面的认识比较笼统。如果想要弄清楚宏任务和微任务，不得不引入一个新的概念——“Tick” Event Loop中，每一次循环称为tick，每一次tick的任务如下： 执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束； 检查是否存在微任务，有则会执行至微任务队列为空； 如果宿主为浏览器，可能会渲染页面； 开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。 所以—— 到底什么是宏任务？什么是微任务？ ES6 规范中，microtask 称为 jobs，macrotask 称为 task宏任务是由宿主发起的，而微任务由JavaScript自身发起。 之前我们提到的异步任务，比如DOM事件，比如ajax，比如定时器，都有一步“开启新线程”，可视为宿主（运行环境）发起。在没有Promise加入的时候，是并没有微任务这一概念的。但是在ES5中引入了Promise，Promise没有对应的线程，事实上也不需要开启新的线程，JavaScript引擎自己也可以开启异步任务。 所以总结一下————“由宿主发起的异步任务就是宏任务，由JS引擎发起的就是微任务” 而因为以前对这一性质认识的不是很深入，以为只有Promise和process.nextTick两种微任务，然而除了常用的这两种以外，还有一些使用的较少的微任务，比如： 宏任务（macrotask） 微任务（microtask） 谁发起的 宿主（Node、浏览器） JS引擎 具体事件 script (可以理解为外层同步代码)，setTimeout/setInterval ，UI rendering/UI事件 ，postMessage，MessageChannel，setImmediate，I/O（Node.js） Promise，MutaionObserver， Object.observe（已废弃；Proxy 对象替代），process.nextTick（Node.js） 谁先运行 后运行 先运行 会触发新一轮Tick吗 会 不会 宏任务和微任务进入的是一个任务队列吗?很遗憾之前的面试中这个问题答错了……（因为以前就学错了），宏任务和微任务进入的不是同一个队列 浏览器和Nodejs的事件循环？123456789101112131415161718 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ 定时器：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。 待定回调：执行延迟到下一个循环迭代的 I/O 回调。 idle, prepare：仅系统内部使用。 轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 setImmediate() 调度的之外），其余情况 node 将在适当的时候在此阻塞。 检测：setImmediate() 回调函数在这里执行。 关闭的回调函数：一些关闭的回调函数，如：socket.on(&#39;close&#39;, ...)。 坑： setTimeout(fn, 0)会被强制改为setTimeout(fn, 1)，所以通常情况下，即使是零延迟setTimeout也会比setImmediate先执行（除非不是timers阶段开始的） process.nextTick永远遇到立刻执行 拓展-Vue中的 vm.$nextTickvm.$nextTick 接受一个回调函数作为参数，用于将回调延迟到下次DOM更新周期之后执行。 这个API就是基于事件循环实现的。 “下次DOM更新周期”的意思就是下次微任务执行时更新DOM，而vm.$nextTick就是将回调函数添加到微任务中（在特殊情况下会降级为宏任务）。 因为微任务优先级太高，Vue 2.4版本之后，提供了强制使用宏任务的方法。 vm.$nextTick优先使用Promise，创建微任务。 如果不支持Promise或者强制开启宏任务，那么，会按照如下顺序发起宏任务： 优先检测是否支持原生 setImmediate（这是一个高版本 IE 和 Edge 才支持的特性） 如果不支持，再去检测是否支持原生的MessageChannel 如果也不支持的话就会降级为 setTimeout。 至此事件循环知识点梳理完毕！","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.cafuchino.cn/tags/%E9%9D%A2%E8%AF%95/"}],"author":"CafuChino"},{"title":"手动实现vue-router","slug":"手动实现vue-router","date":"2021-03-15T15:07:38.000Z","updated":"2021-04-14T12:45:13.522Z","comments":true,"path":"2021/03/15/manually-implement-vuerouter/","link":"","permalink":"https://www.cafuchino.cn/2021/03/15/manually-implement-vuerouter/","excerpt":"所需的前置知识： 插件 混入 Vue.observable() 插槽 render函数 运行时和完整版的Vue","text":"所需的前置知识： 插件 混入 Vue.observable() 插槽 render函数 运行时和完整版的Vue 实现原理 Vue Router是前端路由，当路径切换时在浏览器判断当前路径，并加载对应组件 Hash模式 URL中#（HashTAG）后面的内容是路径地址 监听hashchange事件 根据当前路由地址找到对应组件并重新渲染 History 模式 通过history.pushState()方法改变地址栏（这一操作只改变地址栏并记录历史，并不真正跳转） 监听popstate事件 根据当前路由地址找到对应组件并重新渲染 回顾核心代码12345678910111213141516// router/index.js// 注册插件Vue.use(VueRouter)// 创建路由对象const router = new VueRouter(&#123; routes: [ &#123; name: &#x27;home&#x27;, path: &#x27;/&#x27;, component: homeComponent &#125; ]&#125;)// main.js// 创建Vue示例， 注册router对象new Vue(&#123; router, render: h =&gt;h(App)&#125;).$mount(&#x27;#app&#x27;) 类图： 接下来要实现的就是这个VueRouter类 属性： options：记录构造函数中传入的对象 **data:{current}**：需要一个响应式的对象，以便地址变化的时候路由可以响应式的更新 routeMap：用于记录路由地址和组件的对应关系，会将路由规则解析到routeMap上 方法： Constructor(Options):VueRouter:构造函数 _install(Vue):void:用于实现Vue的插件机制 init():void:用于调用其他方法 initEvent():void:用于注册popstate事件 createRouteMap():void:初始化routeMap对象，建立路由组建关系 initComponents(Vue):void：用于创建，组件 手写实现install方法install方法是Vue插件机制的关键，在vue插件系统的官方文档中讲述了插件的开发方法，其实主要的部分就是install方法需要做的事情。在这里引用一部分内容： :notebook_with_decorative_cover:官方文档 Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 123456789101112131415161718192021222324252627&gt;MyPlugin.install = function (Vue, options) &#123;&gt;// 1. 添加全局方法或 property&gt;Vue.myGlobalMethod = function () &#123;&gt;// 逻辑...&gt;&#125;&gt;// 2. 添加全局资源&gt;Vue.directive(&#x27;my-directive&#x27;, &#123;&gt;bind (el, binding, vnode, oldVnode) &#123;// 逻辑...&gt;&#125;&gt;...&gt;&#125;)&gt;// 3. 注入组件选项&gt;Vue.mixin(&#123;&gt;created: function () &#123;// 逻辑...&gt;&#125;&gt;...&gt;&#125;)&gt;// 4. 添加实例方法&gt;Vue.prototype.$myMethod = function (methodOptions) &#123;&gt;// 逻辑...&gt;&#125;&gt;&#125; 整理一下我们的手写实现思路： 判断当前插件是否已经被安装（Vue的插件只能安装一次） 添加全局资源 注入组件选项 添加实例方法 判断安装状态显然我们需要一个变量来记录插件是否被安装了，局部变量显然无法记录状态；全局变量会引入外部依赖，显然也不妥，所以鉴于install方法是一个静态方法，其上可以带一个属性。这个属性会长期保持，并可随时访问，很适合这种需求，所以我们只需要： 1234567891011121314export default class VueRouter&#123; /** * Vue.use的时候调用的函数，传入Vue的构造实例， 和可选的选项 * @param &#123;*&#125; Vue Vue的构造实例 * @param &#123;*&#125; options 选项对象（可选） */ static install(Vue, options)&#123; // 1.判断当前插件是否已经被安装 if (VueRouter.install.installed) return; VueRouter.install.installed = true; // 2.把Vue构造函数记录到全局变量 // 3.把创建Vue实例时候传入的router对象注入到Vue实例上 &#125;&#125; 注入组件选项虽然在use的时候已经传入了Vue的构造实例了，但是我们不能通过prototype直接在所有的Vue实例上挂载实例方法。原因是install是静态方法，调用的时候其this指向的是VueRouter类，而不是Vue实例。所以此处必须使用Vue.mixin()来进行注入，这样每一个Vue实例在指定的生命周期钩子被触发的时候都会执行混入的内容，从而达到在每一个Vue实例上注入的效果： 12345678910111213141516171819202122232425let _Vue;export default class VueRouter &#123; /** * Vue.use的时候调用的函数，传入Vue的构造实例， 和可选的选项 * @param &#123;*&#125; Vue Vue的构造实例 * @param &#123;*&#125; options 选项对象（可选） */ static install(Vue, options) &#123; // 1.判断当前插件是否已经被安装 if (VueRouter.install.installed) return; VueRouter.install.installed = true; // 2.把Vue构造函数记录到全局变量(组件内全局，以方便以下逻辑调用) _Vue = Vue // 3.把创建Vue实例时候传入的router对象注入到Vue实例上 _Vue.mixin(&#123; beforeCreate() &#123; // 只需要给vue实例挂载，而不需要给组件挂载，组件是没有$options的 if (this.$options.router) &#123; // 此时this的指向就不再是VueRouter了，而是实例本身了 _Vue.prototype.$router = this.$options.router &#125; &#125; &#125;) &#125;&#125; 构造函数构造函数只需要初始化三个属性，并且将data设为响应式，Vue为我们提供了Vue.observable()方法，可以直接将其转化为响应式的对象，所以构造函数我们可以如下实现： 12345678constructor(options) &#123; this.options = options; this.routerMap = &#123;&#125;; this.data = _Vue.observable(&#123; // 当前地址，默认为根 current: &#x27;/&#x27; &#125;) &#125; createRouteMap方法这一方法可以将Options中传入的路由规则转化为路由键值对的形式，键是路由的地址，值是对应的组件。这样路由变化时，就可以快速的找到对应的组件并将其渲染出来。 123456createRouteMap()&#123; // 遍历所有的路由规则解析并构造键值对 this.options.routes.forEach(route =&gt; &#123; this.routeMap[route.path] = route.component &#125;);&#125; initComponents方法和init方法顾名思义，这个函数用于初始化跟路由相关的两个组件：，。组件接受一个字符串类型的参数to并且标签中的内容会被渲染成a标签。与此同时我们还可以使用init方法将之前的createRouteMap和这一方法包装一下，方便统一调用。 至此完整代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354let _Vue;export default class VueRouter &#123; /** * Vue.use的时候调用的函数，传入Vue的构造实例， 和可选的选项 * @param &#123;*&#125; Vue Vue的构造实例 * @param &#123;*&#125; options 选项对象（可选） */ // eslint-disable-next-line no-unused-vars static install(Vue, options) &#123; // 1.判断当前插件是否已经被安装 if (VueRouter.install.installed) return; VueRouter.install.installed = true; // 2.把Vue构造函数记录到全局变量(组件内全局，以方便以下逻辑调用) _Vue = Vue // 3.把创建Vue实例时候传入的router对象注入到Vue实例上 _Vue.mixin(&#123; beforeCreate() &#123; // 只需要给vue实例挂载，而不需要给组件挂载，组件是没有$options的 if (this.$options.router) &#123; // 此时this的指向就不再是VueRouter了，而是实例本身了 _Vue.prototype.$router = this.$options.router this.$options.router.init() &#125; &#125; &#125;) &#125; constructor(options) &#123; this.options = options; this.routeMap = &#123;&#125;; this.data = _Vue.observable(&#123; // 当前地址，默认为根 current: &#x27;/&#x27; &#125;) &#125; init()&#123; this.createRouteMap(); this.initComponents(_Vue) &#125; createRouteMap()&#123; // 遍历所有的路由规则解析并构造键值对 this.options.routes.forEach(route =&gt; &#123; this.routeMap[route.path] = route.component &#125;); &#125; initComponents(Vue)&#123; Vue.component(&#x27;router-link&#x27;, &#123; props:&#123; to: String, &#125;, template:&#x27;&lt;a :href=&quot;to&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;&#x27; &#125;) &#125;&#125; 到这一步，路由就可以正常跳转了（虽然还不能显示），其实核心工作就是进行了一步解析，一步混入挂载，一步声明router-link（实际上就是个a标签）。如果你熟悉vue的源码或原理，对render中的h函数必然不会感到陌生了。但是其实这个时候的跳转不是我们想要的跳转，我们想要的跳转并不是真正的跳转，而是只改变地址栏和渲染的组件，所以我们必须进一步阻止a标签的默认行为，并调用pushStateapi来改变地址栏： 123456789101112131415161718192021222324initComponents(Vue) &#123; Vue.component(&#x27;router-link&#x27;, &#123; props: &#123; to: String, &#125;, render(h) &#123; return h(&#x27;a&#x27;, &#123; attrs: &#123; href: this.to &#125;, on: &#123; click: this.clickHandler &#125; &#125;, [this.$slots.default]) &#125;, methods: &#123; clickHandler(e) &#123; history.pushState(&#123;&#125;, &#x27;&#x27;, this.to); this.$router.data.current = this.to e.preventDefault() &#125; &#125; &#125;) &#125; 经过一番修改，我们成功的阻止了默认行为，并且通过api改变了地址栏内容，修改了current响应式参数的值。不过这个时候组件还不能被渲染，因为我们还没有声明router-view组件。render函数也可以直接帮助我们渲染一个组件。既然current是响应式的，当current发生变化的时候，渲染的内容自然而然的就会发生变化了。唯一的问题在于，在render函数中，this的指向是指向该实例内部的this而不是VueRouter对象的，所以我们不可以在这里直接使用this。带有router-view组件的完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677let _Vue;export default class VueRouter &#123; /** * Vue.use的时候调用的函数，传入Vue的构造实例， 和可选的选项 * @param &#123;*&#125; Vue Vue的构造实例 * @param &#123;*&#125; options 选项对象（可选） */ // eslint-disable-next-line no-unused-vars static install(Vue, options) &#123; // 1.判断当前插件是否已经被安装 if (VueRouter.install.installed) return; VueRouter.install.installed = true; // 2.把Vue构造函数记录到全局变量(组件内全局，以方便以下逻辑调用) _Vue = Vue // 3.把创建Vue实例时候传入的router对象注入到Vue实例上 _Vue.mixin(&#123; beforeCreate() &#123; // 只需要给vue实例挂载，而不需要给组件挂载，组件是没有$options的 if (this.$options.router) &#123; // 此时this的指向就不再是VueRouter了，而是实例本身了 _Vue.prototype.$router = this.$options.router this.$options.router.init() &#125; &#125; &#125;) &#125; constructor(options) &#123; this.options = options; this.routeMap = &#123;&#125;; this.data = _Vue.observable(&#123; // 当前地址，默认为根 current: &#x27;/&#x27; &#125;) &#125; init() &#123; this.createRouteMap(); this.initComponents(_Vue) &#125; createRouteMap() &#123; // 遍历所有的路由规则解析并构造键值对 this.options.routes.forEach(route =&gt; &#123; this.routeMap[route.path] = route.component &#125;); &#125; initComponents(Vue) &#123; Vue.component(&#x27;router-link&#x27;, &#123; props: &#123; to: String, &#125;, render(h) &#123; return h(&#x27;a&#x27;, &#123; attrs: &#123; href: this.to &#125;, on: &#123; click: this.clickHandler &#125; &#125;, [this.$slots.default]) &#125;, methods: &#123; clickHandler(e) &#123; history.pushState(&#123;&#125;, &#x27;&#x27;, this.to); this.$router.data.current = this.to e.preventDefault() &#125; &#125; &#125;) const self = this; Vue.component(&#x27;router-view&#x27;, &#123; render(h)&#123; const component = self.routeMap[self.data.current]; return h(component) &#125; &#125;) &#125;&#125; 现在我们就完美的实现了所有功能。除了最后一个问题——当我们点击浏览器后退时会怎么样，当然什么都不会发生。因为地址栏虽然发生了变化，但是current没有发生变化，current没有发生变化组件就不会变化，所以什么都不会发生，而如果我们希望组件也变化，那么便需要监听popstate事件。 initEvent方法这一部分很简单，我们只需要添加一个全局的popstate的事件监听，并将地址赋值给current即可： 12345initEvent()&#123; window.addEventListener(&#x27;popstate&#x27;, ()=&gt;&#123; this.data.current = window.location.pathname &#125;)&#125; 当然，不要忘记在init()函数中调用一下这个初始化函数，这样我们才算是真正的自己实现了vue-router。 完整代码参见github","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[],"author":"CafuChino"},{"title":"函数式编程原理(3)","slug":"03-函数式编程原理","date":"2021-01-28T10:58:58.000Z","updated":"2021-04-14T12:45:33.013Z","comments":true,"path":"2021/01/28/principles-of-functional-programming-3/","link":"","permalink":"https://www.cafuchino.cn/2021/01/28/principles-of-functional-programming-3/","excerpt":"00-接上篇说起函数式编程，我觉得与其专注于lodash或者rambda这些实现的函数，我可能更倾向从moment入手。因为他是我用过最多也是最接近函数式编程的库。在我还对js和函数式编程不甚了解的时候，我曾思考过一个问题：为什么moment.js的各个功能函数可以以几乎任何次序无限的链式调用下去？ 最后我得到的认为最满意的结果是：每一个功能函数都是一个对象上的方法，每一个功能方法的返回值都是这个对象 。虽然这个想法不甚准确，但是其实已经比较接近函数式编程的本质了。或者说，接近函数式编程的具体实现了。那就是——“函子”","text":"00-接上篇说起函数式编程，我觉得与其专注于lodash或者rambda这些实现的函数，我可能更倾向从moment入手。因为他是我用过最多也是最接近函数式编程的库。在我还对js和函数式编程不甚了解的时候，我曾思考过一个问题：为什么moment.js的各个功能函数可以以几乎任何次序无限的链式调用下去？ 最后我得到的认为最满意的结果是：每一个功能函数都是一个对象上的方法，每一个功能方法的返回值都是这个对象 。虽然这个想法不甚准确，但是其实已经比较接近函数式编程的本质了。或者说，接近函数式编程的具体实现了。那就是——“函子” 01-函子——一份带原材料的工具箱如果要我不准确但是形象的概括什么是函子，我会把它描述成一个带有原材料的工具箱。 比如说一个最基础的Functor函子： 123456789101112131415161718// 一个容器，包裹一个值class Container &#123;// of 静态方法，可以省略 new 关键字创建对象static of (value) &#123;return new Container(value)&#125;constructor (value) &#123;this._value = value&#125;// map 方法，传入变形关系，将容器里的每一个值映射到另一个容器map (fn) &#123;return Container.of(fn(this._value))&#125;&#125;// 测试Container.of(3).map(x =&gt; x + 2).map(x =&gt; x * x) 可以看出，我们的函子其实什么都没有做，他只是提供了一个创建自身的静态方法，并且提供了返回“这个容器”的方法。看到这我们就可以迫不及待的来实现一下Moment了，比如： 123456789101112class Moment&#123; static of(value)&#123; return new Moment(value) &#125; constructor(value)&#123; this._value = value &#125; format(str)&#123; // 一些用来格式化的操作 return Moment.of(result) &#125;&#125; 很显然，我们想调用多少次.format()方法都可以，因为无论进行多少次format，返回的对象上都有format这个方法。 （当然，Moment内部可能不是这么设计的，这也不是函子的绝对正确用法，不过这个可以很好的体现of这个操作的思想） 很显然，函子就是链式调用的起源，函子这种返回自身对象的思路使得我们可以近乎无限的链式调用下去。 MayBe 函子当然我们的程序无论如何都不可能完全排除副作用，我们必须接受不确定的输入，或者是进行某些对外界环境的操作。如果一定要要求没有副作用，那么几乎无法使用函数式编程。所以我们要做的事情就是把副作用控制在可以接受的范围。比如，我们在接受外界输入或者是进行io的时候，经常可能遇到空，这就可能存在副作用。Maybe函子可以对外界为空的时候做出处理： 12345678910111213141516171819202122class MayBe &#123; static of (value)&#123; return new MayBe(value) &#125; constructor (value) &#123; this._value = value &#125; // 如果对空值变形的话直接返回 值为 null 的函子 map (fn) &#123; return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value)) &#125; isNothing () &#123; return this._value === null || this._value === undefined &#125;&#125;// 传入具体值MayBe.of(&#x27;Hello World&#x27;).map(x =&gt; x.toUpperCase())// 传入 null 的情况MayBe.of(null).map(x =&gt; x.toUpperCase())// =&gt; MayBe &#123; _value: null &#125;&#123; 可以看出，Maybe函子相较于普通函子，多做的一件事就是当传入空的时候直接返回空，而不进行函数运算。这就把副作用控制在了可以接受的范围，但是这样只要中间异步出现空，之后的结果就都是空了。 Either 函子异常也会使函数变的不是纯函数（出现了与预期不同的结果），而Either函子可以用于分支判断，控制异常。 12345678910111213141516171819202122class Left &#123; static of (value) &#123; return new Left(value) &#125; constructor (value) &#123; this._value = value &#125; map (fn) &#123; return this &#125;&#125;class Right &#123; static of (value) &#123; return new Right(value) &#125; constructor (value) &#123; this._value = value &#125; map(fn) &#123; return Right.of(fn(this._value)) &#125;&#125; 可以看出，Either函子是一个普通的Functor配合一个什么都不会做只会返回自身的函子，这样就可以将错误传递下去。 IO函子我们之前有提到过，副作用的一个主要的来源就是IO操作，IO操作可能会带来各种不同的副作用。而这类操作通常都是程序的核心任务类型之一（比如操作数据库，redis，文件等等）。我们不能消除副作用，但是可以控制副作用——通过把分部出现的副作用一次性的执行的方法。这样程序只需要负责纯函数的部分就可以了，副作用可以交给用户来处理。简单的来说就是：把会产生副作用的操作合并在一起执行（使用之前提到过的函数聚合）、 1234567891011121314151617const fp = require(&#x27;lodash/fp&#x27;)class IO &#123; static of (x) &#123; return new IO(function () &#123; return x &#125;) &#125; constructor (fn) &#123; this._value = fn &#125; map (fn) &#123; // 把当前的 value 和 传入的 fn 组合成一个新的函数 return new IO(fp.flowRight(fn, this._value)) &#125;&#125;let io = IO.of(process).map(p =&gt; p.execPath)console.log(io._value()) Task函子异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示。folktale是一个标准的函数式编程库，和 lodash、ramda 不同的是，他没有提供很多功能函数。只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task、Either、MayBe 等folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的函子，这里以 2.3.2 来演示 12345678910111213141516171819202122232425262728293031323334let io = IO.of(process).map(p =&gt; p.execPath)console.log(io._value())const &#123; compose, curry &#125; = require(&#x27;folktale/core/lambda&#x27;)const &#123; toUpper, first &#125; = require(&#x27;lodash/fp&#x27;)// 第一个参数是传入函数的参数个数let f = curry(2, function (x, y) &#123;console.log(x + y)&#125;)f(3, 4)f(3)(4)// 函数组合let f = compose(toUpper, first)f([&#x27;one&#x27;, &#x27;two&#x27;])const &#123; task &#125; = require(&#x27;folktale/concurrency/task&#x27;)function readFile(filename) &#123;return task(resolver =&gt; &#123;fs.readFile(filename, &#x27;utf-8&#x27;, (err, data) =&gt; &#123;if (err) resolver.reject(err)resolver.resolve(data)&#125;)&#125;)&#125;// 调用 run 执行readFile(&#x27;package.json&#x27;).map(split(&#x27;\\n&#x27;)).map(find(x =&gt; x.includes(&#x27;version&#x27;))).run().listen(&#123;onRejected: err =&gt; &#123;console.log(err)&#125;,onResolved: value =&gt; &#123;console.log(value)&#125;&#125;) Monad函子在JavaScript的Class中并没有提供严格的“私有属性”特性，我们只能通过在属性名前面加上_下划线来约定这个属性是一个私有属性，或是使用Symbol数据类型实现私有属性。当我们需要获取函子中的_value时直接获取“私有属性”显然是不符合约定的。正如我们使用of函数避免使用new来创建新对象一样，我们也可以通过join函数来返回_value来避免直接获取私有属性。一个函子如果具有join和of两个方法并且遵守一些规律就是一个Monad函子。 12345678910111213141516171819202122232425const fp = require(&#x27;lodash/fp&#x27;)// IO Monadclass IO &#123;static of (x) &#123;return new IO(function () &#123;return x&#125;)&#125;constructor (fn) &#123;this._value = fn&#125;map (fn) &#123;return new IO(fp.flowRight(fn, this._value))&#125;join () &#123;return this._value()&#125;flatMap (fn) &#123;return this.map(fn).join()&#125;&#125;let r = readFile(&#x27;package.json&#x27;).map(fp.toUpper).flatMap(print).join() 02-总结有关函数式编程的笔记就记录到这里。概括一下函数式编程的一些知识点： 纯函数对于相同的输入总有相同的输出，而且不会带来副作用 柯里化就是把一个多元纯函数变成一个一元纯函数 柯里化的原理就是暂存传入的参数，等到参数全部传入再执行，实现原理为闭包 柯里化的目的是便于函数组合 函数组合的目的是消除洋葱代码，将执行过程进行封装 可以利用函子实现函数式编程 函子的作用是实现链式调用和控制副作用 副作用不可能被消除，但可以被控制 （完）","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.cafuchino.cn/tags/Javascript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.cafuchino.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"author":"CafuChino"},{"title":"函数式编程原理(2)","slug":"02-函数式编程原理","date":"2021-01-26T13:54:58.000Z","updated":"2021-04-14T12:45:30.538Z","comments":true,"path":"2021/01/26/principles-of-functional-programming-2/","link":"","permalink":"https://www.cafuchino.cn/2021/01/26/principles-of-functional-programming-2/","excerpt":"00-接上篇在上一篇中主要记录了函数柯里化的基本概念和手动实现，当然如果在每一个项目中都手动实现一遍柯里化显然是不方便的。其次，函数柯里化在函数式编程中具体有哪些应用模式呢？本篇将主要讲述柯里化的使用和函数式编程的应用。","text":"00-接上篇在上一篇中主要记录了函数柯里化的基本概念和手动实现，当然如果在每一个项目中都手动实现一遍柯里化显然是不方便的。其次，函数柯里化在函数式编程中具体有哪些应用模式呢？本篇将主要讲述柯里化的使用和函数式编程的应用。 01-Lodash中的柯里化功能lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。在其内部将我们生产和开发中的许多常用功能抽象成了各种函数以方便调用（虽然他们不一定都是纯函数），其中便提供了curry和curryRight方法，这一方法可以帮助我们将函数柯里化。其中curry方法与我们自己实现的函数使用方法差异不多，如下： 12345678910111213141516171819var abc = function(a, b, c) &#123; return [a, b, c];&#125;;var curried = _.curry(abc);curried(1)(2)(3);// =&gt; [1, 2, 3]curried(1, 2)(3);// =&gt; [1, 2, 3]curried(1, 2, 3);// =&gt; [1, 2, 3]// Curried with placeholders.curried(1)(_, 3)(2);// =&gt; [1, 2, 3] 而curryRight除了 会生成柯里化之后的函数之外，其传递参数的顺序是由后向前。 02-初步总结柯里化至此，单纯关于柯里化的内容已经完毕，柯里化的优点和作用已然明了： 柯里化可以通过闭包的方式实现生成一个“缓存了一部分参数的函数”从而使我们能够无压力的抽象细粒度的函数而不必担心传入的参数过多的不便。 但是柯里化显然不止是开发上多传一个或者少传一个参数的问题，柯里化的核心其实是将一个多元函数转换成一个一元函数，而为什么要组合成一元函数呢？答案是：函数组合 03-函数组合首先假设我们需要设计这样一个函数，这个函数的目的是获取数组的最后一个元素并且转换为大写字母，如果应用我们之前所涉及的柯里化和纯函数，我们理所当然的会写出这样的代码： 1_.toUpper(_.first(_.reverse(array))) 这种代码虽然可以正常并且顺利的获得我们想要的结果，但是这种“洋葱代码”的层层嵌套如果层级太多就会不利于代码的编写和维护。所以在这种情况我们就不再适合嵌套使用，而是使用“函数组合”： 函数组合可以让我们把细粒度的函数重新组合生成一个新的函数 函数组合的思想是一种由从内到外编写格式到依次执行思路的转变，他有点像pipeline，但是完全不同，不过这并不能阻止你将他想像成一个管道： 如果说一个纯函数是一个完整的管道，接受一个输入，并提供一个输出，就像： 那么使用纯函数的函数组合就像是把一个复杂的多个管道转变成一个个连接在一起的细分小管道： 到这之前的铺垫就都讲得通了，之所以要将函数进行柯里化，是因为需要将多元函数转变为一元函数。而需要一元纯函数的原因，就是在具体组合应用的时候方便进行函数组合。函数组合思想的便利之处就在于，我们可以放心的尽可能细粒度的抽象函数而不必担心调用时过于复杂的问题。我们在应用的时候只要拿出足够细粒度的函数“积木”进行进一步的功能通过组合函数进行整合即可（需要注意的是组合函数的执行顺序是从右到左）。如： 123456789101112131415// 组合函数function compose (f, g) &#123;return function (x) &#123;return f(g(x))&#125;&#125;function first (arr) &#123;return arr[0]&#125;function reverse (arr) &#123;return arr.reverse()&#125;// 从右到左运行let last = compose(first, reverse)console.log(last([1, 2, 3, 4])) 看过代码，相信“从右到左”这个似乎很反常规的规则的原因也已经明了了，虽然我们传参的顺序是(f, g)，但是只要想像一下内部的“洋葱代码”，就可得知其实洋葱的最内部是”g“，是内部的函数先执行。 而这样的解决方式显然还是不够“优雅”，你可能会发现其实只是把洋葱代码换了个地方写了而已，而且这种函数组合只能处理两个函数的情况。如果我们需要使用多个函数的组合又该怎么办呢？Lodash为我们提供了解决方案flow()和flowRight()，其中flowRight便是从右到左执行的组合方式。这种方式在实际应用中会使用的更多一点（因为他能更好的帮助我们去想像其中的洋葱函数？？？）。如： 123456const _ = require(&#x27;lodash&#x27;)const toUpper = s =&gt; s.toUpperCase()const reverse = arr =&gt; arr.reverse()const first = arr =&gt; arr[0]const f = _.flowRight(toUpper, first, reverse)console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])) 可以看出我们很优雅的将三个细粒度的纯函数进行了组合形成了一个全新的函数f()，比洋葱代码要好维护得多了。 以下是面试专用手写一切时间！！！ 在面试的的时候如果面试官问起函数组合是如何实现的，我们可以给出这样一个思路： 获取传入所有参数的伪数组 将其反转（因为我们需要从右向左依次执行） 依次组合函数，并将前一个函数的返回值作为后一个函数的参数 返回生成的函数 如果面试官问：那么用代码如何实现呢，我们便可以仅用一行代码展现自己优秀的编程水平（并不），如： 12const compose = (...fns) =&gt; value =&gt; fns.reverse().reduce((acc, fn) =&gt;fn(acc), value) 在这行代码中我们依然使用了…参数的这样的剩余参数用法以获取所有的参数构成的伪数组。之后我们简单的将其简单的reverse()。然后调用了reduce()方法。（这里值得好好说一下） reduce函数是一个累加器，它接受一个函数作为参数，并且返回数组中每一个元素通过这个函数进行累加之后的值。这样说可能比较抽象，我们可以用数组求和来举个栗子。 1234567891011var numbers = [65, 44, 12, 4];function getSum(total, num) &#123; return total + num;&#125;function myFunction(item) &#123; document.getElementById(&quot;demo&quot;).innerHTML = numbers.reduce(getSum);&#125; reduce函数会将累加中间结果作为第一个参数，数组项作为第二个参数传入提供的函数，从而返回最终结果。在这个案例中我们会对这个数组中的每一项进行求和。 回到我们手写的compose函数，我们的函数接受一系列参数，返回的内容是一个接受一个value参数的函数，函数的内部会累加执行当前函数并且将之前函数的结果作为参数，当然还会传入我们传入的value作为初始参数。翻译成更好理解的方式就是： 123456789const compose = (...fns) =&gt; value =&gt; fns.reverse().reduce((acc, fn) =&gt;fn(acc), value)const compose = (...fns) =&gt; &#123; return value =&gt; &#123; return fns.reverse().reduce((acc, fn)=&gt;&#123;return fn(acc)&#125;, value) &#125;&#125; 你学废了吗？ 04-调试组合函数调试组合函数…..就是在调用的一串函数中间插一个柯里化过的额外函数，然后将接收到的中间参数原样返回传递下去就可以了….（其实可能不如打个断点？） 示例代码 1234567891011const _ = require(&#x27;lodash&#x27;)const trace = _.curry((tag, v) =&gt; &#123;console.log(tag, v)return v&#125;)const split = _.curry((sep, str) =&gt; _.split(str, sep))const join = _.curry((sep, array) =&gt; _.join(array, sep))const map = _.curry((fn, array) =&gt; _.map(array, fn))const f = _.flowRight(join(&#x27;-&#x27;), trace(&#x27;map 之后&#x27;), map(_.toLower),trace(&#x27;split 之后&#x27;), split(&#x27; &#x27;))console.log(f(&#x27;NEVER SAY DIE&#x27;)) 05-Point free其实前面几千字的铺垫都是为了这一点……. Point free 编程顾名思义就是他可以省去一些东西，而被free的point是什么呢？你可以这样理解： 如果我们清楚的知道一个公式的计算过程，那么我们即使不提供任何数据，就可以表达出这个公式，并且确信他能达到预期的结果。 而这就需要纯函数，柯里化，函数组合等概念作为前提： 如果一个函数会产生副作用，那么就无法确定预期结果（是否为纯函数） 如果一个函数是多元函数，那么就必须额外提供参数（不需要提供任何数据） 如果一个函数可以被组合，那么他就可以用来表示程序的计算过程（表达出一个公式） PointFree这一特点通常用来封装一个底层函数，这样我们无需了解其内部的运作流程，只要调用这个函数就可以了，比如： 123456789101112131415// Hello World =&gt; hello_worldfunction f (word) &#123;return word.toLowerCase().replace(/\\s+/g, &#x27;_&#x27;);&#125;// Point Freeconst fp = require(&#x27;lodash/fp&#x27;)const f = fp.flowRight(fp.replace(/\\s+/g, &#x27;_&#x27;), fp.toLower)console.log(f(&#x27;Hello World&#x27;))const fp = require(&#x27;lodash/fp&#x27;)const firstLetterToUpper = fp.flowRight(join(&#x27;. &#x27;),fp.map(fp.flowRight(fp.first, fp.toUpper)), split(&#x27; &#x27;))console.log(firstLetterToUpper(&#x27;world wild web&#x27;))// =&gt; W. W. W 06-函数式编程相关库lodash/fp lodash 的 fp 模块提供了实用的对函数式编程友好的方法 提供了不可变 auto-curried iteratee-first data-last 的方法 （意思就是所有的函数都已经柯里化过，如果同时传参后传数据） 1234567891011121314151617// lodash 模块const _ = require(&#x27;lodash&#x27;)_.map([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], _.toUpper)// =&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]_.map([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])// =&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]_.split(&#x27;Hello World&#x27;, &#x27; &#x27;)// lodash/fp 模块const fp = require(&#x27;lodash/fp&#x27;)fp.map(fp.toUpper, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])fp.map(fp.toUpper)([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])fp.split(&#x27; &#x27;, &#x27;Hello World&#x27;)fp.split(&#x27; &#x27;)(&#x27;Hello World&#x27;)//-------------------------------------const fp = require(&#x27;lodash/fp&#x27;)const f = fp.flowRight(fp.join(&#x27;-&#x27;), fp.map(_.toLower), fp.split(&#x27; &#x27;))console.log(f(&#x27;NEVER SAY DIE&#x27;)) 本系列/专栏为拉勾教育-大前端高薪训练营学习笔记，内容为本系列课程的讲授内容、亮点题目分析、重点难点的总结、以及个人的体会。个人感觉拉勾教育比体验过的其他教育平台要更好一点。老师讲授的内容比较全面，相对于自学可以节省很多不必要的走弯路的时间，可以更快的使自己在技术上系统的有所提高。同时随堂测的题目也很用代表性，老师跟进解答很快，推荐和我一样在自学路上遇到瓶颈或者找不到进一步学习方向的同学尝试一下。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.cafuchino.cn/tags/Javascript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.cafuchino.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"author":"CafuChino"},{"title":"函数式编程原理(1)","slug":"01-函数式编程原理","date":"2021-01-22T06:26:58.000Z","updated":"2021-04-14T12:45:27.899Z","comments":true,"path":"2021/01/22/principles-of-functional-programming-1/","link":"","permalink":"https://www.cafuchino.cn/2021/01/22/principles-of-functional-programming-1/","excerpt":"00 - 序本系列/专栏为拉勾教育-大前端高薪训练营学习笔记，内容为本系列课程的讲授内容、亮点题目分析、重点难点的总结、以及个人的体会。个人感觉拉勾教育比体验过的其他教育平台要更好一点。老师讲授的内容比较全面，相对于自学可以节省很多不必要的走弯路的时间，可以更快的使自己在技术上系统的有所提高。同时随堂测的题目也很用代表性，老师跟进解答很快，推荐和我一样在自学路上遇到瓶颈或者找不到进一步学习方向的同学尝试一下。","text":"00 - 序本系列/专栏为拉勾教育-大前端高薪训练营学习笔记，内容为本系列课程的讲授内容、亮点题目分析、重点难点的总结、以及个人的体会。个人感觉拉勾教育比体验过的其他教育平台要更好一点。老师讲授的内容比较全面，相对于自学可以节省很多不必要的走弯路的时间，可以更快的使自己在技术上系统的有所提高。同时随堂测的题目也很用代表性，老师跟进解答很快，推荐和我一样在自学路上遇到瓶颈或者找不到进一步学习方向的同学尝试一下。 01 - 说说函数式编程之前阅读一些经验丰富的开发者的源码，或者使用某些库的时候。我经常发现，有的代码可以一直“点下去”。比如： 1234567891011// maybefunction badCode(para)&#123; let temp = sth.doSth(para) temp = sth.doAnother(temp) return sth&#125;// but ?function elegentCode(para)&#123; return sth(para).doSth().doAnother()&#125; 或者，当我需要抽象某一个经常会使用到的功能函数，但我不希望把每一个我需要用到的属性全部当作参数传入。然而我又希望这个函数可以用在更多的地方，有更好的可复用性，所以我可能会这样做： 123456function translateAFile(&#123; safeNoFile:true, default:&#x27;English&#x27;, defaultTarget:&#x27;Chinese&#x27;, path&#125;) 但是这样依然非常的“不优雅”，我想到可能可以拆分成更小粒度的函数进行整合，我可能会： 1234567function readFile()&#123; //do Sth.&#125;function requestTranslate()&#123; // do Sth.&#125;// more function 但是这样依然很麻烦，我不仅要记住所有的函数名，函数的参数和返回值，而中间任何一步的错误没有正确捕获，或美誉正确进行转换就会引发错误，大大增加了测试和开发的成本，反而不方便了。在这种情况下，“一直点下去”的方法显然就会优雅很多。但是……这其中是如何实现的呢？这可能要说到函数式编程。 02 - 函数式编程的位置面对函数式编程，在考虑如何实现之前，可能要先研究一下函数式编程到底式什么层次的概念。函数式编程是一种编程范式，可以理解为与面向过程编程和面向对象编程同级。 如果说面向过程专注与逻辑的先后次序，逐步执行；面向对象编程专注与抽象对象和对象的属性和方法；函数式编程的关注点可能是“联系”，从这一点上，它就很“函数”，数学的那种“函数”。 03 - 函数式编程依赖的特点和前提因为在JS中函数是一等公民，我们可以“随意”的使用函数，函数就是一个普通的对象（可以通过new Function()来创建）。函数可以赋值给变量，可以使用new Function()构造,甚至可以以作为另一个函数的返回值，而这是函数式编程的前提，是高阶函数，柯里化得以实现和应用的必须特性。 高阶函数JS中，函数可以作为参数传递给另一函数，同时也可以作为一个函数的返回值。对于函数作为参数，我想每一个人都不陌生，每天都会使用。当我们需要为一个异步操作提供回调函数的时候，如： 12345function doSomeThing(foo,callback)&#123; // doSth var result = bar.doSth(foo) callback()&#125; 此时，一个回调函作为函数的参数被传入，并且在函数中被调用。同时，函数也可作为一个函数的返回值，之前有提到过，函数可以赋值给变量。那么我们可以推断，当一个函数返回一个函数的时候，如果使用一个变量接收这个函数，我们就可以使用这个变量名+括号的形式来调用他，就像我们在把函数作为参数的情况一样。比如： 12345678function makeFn () &#123;let msg = &#x27;Hello function&#x27;return function () &#123;console.log(msg)&#125;&#125;const fn = makeFn()fn() 我们可以看到，由于闭包的存在，声明的msg变量的作用域虽然局限在makeFn内部，但是我们在调用的时候，msg依然存在，没有被GC。在这里，它相当于被作为一种状态保存下来了。我们运行Fn()依然能顺利的在控制台打印Hello function。 这就隐隐的和之前的案例产生关联：“当我需要一些参数，但我不希望每次调用都传入，又想使耦合度降低，提高复用性”，高阶函数似乎提供了一种方案。他可以通过闭包返回一个包含一个我们需要的状态的函数，然后我们调用“生成的函数”就好了。这就是高阶函数的优点，概括起来说就是： 抽象可以帮我们屏蔽细节，只需要关注与我们的目标 高阶函数是用来抽象通用的问题 以上特点的存在，使得高阶函数成为我们函数式编程中一个不可或缺的部分。 纯函数在讨论纯函数之前，我们先看几个案例： 123456789101112131415let numbers = [1, 2, 3, 4, 5]numbers.slice(0, 3)// =&gt; [1, 2, 3]numbers.slice(0, 3)// =&gt; [1, 2, 3]numbers.slice(0, 3)// =&gt; [1, 2, 3]numbers.splice(0, 3)// =&gt; [1, 2, 3]numbers.splice(0, 3)// =&gt; [4, 5]numbers.splice(0, 3)// =&gt; [] 我们可以看到，对于slice()和splice()，在第一次执行的时候，都会返回数组的前三项。但是当继续执行的时候，splice()的执行结果就变的与预期不同了。假设我们抽象了这一逻辑，那么在多次，多处，或者链式调用的时候，情况就会变的复杂且难以控制。我们把这种情况叫做“函数具有副作用”。副作用的产生通常是函数内部改变了外部状态，或函数依赖于某一外部状态。这种“依赖”就会使得函数变的“不纯”。副作用的来源通常可能是： 配置文件 数据库 用户输入 文件系统 …… 与此同时我们也可以得出纯函数的特点： 无论多少次执行，相同的输入总会得到相同的输出 纯函数不会保留中间计算的结果，变量是不可变的 因为纯函数的输入和输出我们都可以预期，所以我们很清楚函数的执行结果。这会给我们带来很多好处，比如： 可缓存——因为相同的输入总会得到相同的输出。所以如果对于一个耗时的操作，我们可以将结果缓存，并且重复执行的时候返回缓存的结果以节省时间和资源。 易测试——因为纯函数的执行不依赖外部状态，只依赖明确的输入，所以可以不受限制的单独进行测试。 并行安全——因为纯函数不需要访问共享的内存数据，也不会产生副作用，每一次执行都是相对独立的，所以在并行环境下可以十分看全的运行纯函数。 那么如何把一个不纯的函数变成纯函数呢？有两种方法，增加参数和硬编码。如： 123456789101112131415161718//一个不纯的函数let mini = 18function checkAge (age) &#123;return age &gt;= mini&#125;// 第一种方法function checkAgeNew(age, target)&#123; return age &gt;= target&#125;// 第二种方法function checkAgeHardcode(age)&#123; let mini = 18 return age &gt;= mini&#125; 但是这两种方法都会带来另外的问题，第一种方法增加了参数，传递变的不方便。而且一但需要修改基准年龄，需要更改所有的调用，一但漏掉就会引发bug。第二种缺点变的更加的明显，众所周知在编程中我们要尽力的避免硬编码。以降低程序的耦合度。难道为了函数式编程我们就不得不向这些缺点妥协么？ 04 - 柯里化如果说让我用一句话来概括“柯里化”，就是利用闭包先预先“储存”一个参数，再通过高阶函数返回一个已经预先填好一个参数的新函数。简言之——柯里化过后的函数就是一个函数生成器。感觉还是有点绕，回到刚才的问题上。我们需要一个检查年龄是否合规的函数。 123456789101112131415161718192021222324function checkAge (age) &#123;let min = 18return age &gt;= min&#125;// 普通纯函数function checkAge (min, age) &#123;return age &gt;= min&#125;checkAge(18, 24)checkAge(18, 20)checkAge(20, 30)// 柯里化function checkAge (min) &#123;return function (age) &#123;return age &gt;= min&#125;&#125;// ES6 写法let checkAge = min =&gt; (age =&gt; age &gt;= min)let checkAge18 = checkAge(18)let checkAge20 = checkAge(20)checkAge18(24)checkAge18(20) 通过上面的代码，我们可以进一步概括一个可能不那么准确但是非常好理解的概念——“柯里化就是利用闭包，返回一个已经动态的把其中一部分参数硬编码的函数”。这样一方面拥有硬编码只需要传递一部分参数的优点，一方面减小了调用的难度（如果需要修改只需要修改柯里化的部分就可以了） 尝试实现柯里化柯里化很方便，但是我们手动把每一个函数都柯里化会非常费神。那么我们如何编写一个函数，帮助我们把多个参数的纯函数柯里化呢？我们可以简单整理一下需求，比如先把这个函数命名为“curry”： curry函数需要把我们需要柯里化的函数作为输入 curry函数需要返回一个函数 柯里化过的函数，需要在没有提供足够多的参数的时候“暂存”已经输入的参数，并继续接收输入 当输入了完整的参数时，被柯里化的函数就会执行 接下来我们来尝试实现一下这一函数： 123456789101112function curry (func) &#123;return function curriedFn (...args) &#123;// 判断实参和形参的个数if (args.length &lt; func.length) &#123;return function () &#123;return curriedFn(...args.concat(Array.from(arguments)))&#125;&#125;// 实参和形参个数相同，调用 func，返回结果return func(...args)&#125;&#125; 为了实现这一需求，我们首先使用了剩余参数语法，即...args。这个语法允许我们将一个不定数量的参数表示为一个数组，如： 1234function sum(...args)&#123; console.log(args)&#125;sum(1,2,3,4) // [1, 2, 3, 4] 同时我们使用了另一特性——一个函数的length属性为他的参数个数，如： 1234function sum(a, b)&#123; return a + b&#125;console.log(sum.length) // 2 解释了这些之后这一函数就很好理解了，接下来尝试一下它的应用： 12345678function sum(a, b, c)&#123; return a + b +c&#125;var curriedSum = curry(sum)curriedSum(1)(2)(2) // 5curriedSum(1, 2)(2) // 5curriedSum(1)(2,2) // 5 不难看出，函数成功的被柯里化了，我们可以分多次，每次传入任意个数的参数即可。函数都将正常地被执行。 本篇主要讲述了函数式编程的思想，核心功能特点，以及柯里化。在下一篇中我们将进一步的讲述函数式编程以及柯里化的实际应用；以及进一步解决柯里化可能带来的问题。 https://t2.lagounews.com/fR8DRXRXcu024 前端福音！这次彻底搞懂 Webpack 原理与实践，做合格前端“配置”工程师！点击链接7天搞定webpack原理和实践，仅需19元√强烈推荐！","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.cafuchino.cn/tags/Javascript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.cafuchino.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}],"author":"CafuChino"},{"title":"VUE源码解读（1）","slug":"VUE源码解读（1）","date":"2020-12-06T09:47:19.000Z","updated":"2021-04-12T15:19:14.000Z","comments":true,"path":"2020/12/06/vue-source-code-interpretation-1/","link":"","permalink":"https://www.cafuchino.cn/2020/12/06/vue-source-code-interpretation-1/","excerpt":"Vue源码解读学习笔记系列，逐步深入解读Vue设计和源码。 ——CafuChino 从虚拟DOM说起在使用Vue之前，Web项目最常用的库是Jquery。Jquery封装了各种常用的domApi，可以大大简化dom操作的难度，所以广受欢迎。但是无论是使用原生Js还是Jquery，当页面进行更新时依然要进行大量的DOM操作，如果要更改一个数据，可能需要逐层找到它的DOM元素，然后在对其进行更改。在开发大型项目时可能一次性要对大量DOM进行操作，这不仅会加大开发难度，还会加剧性能消耗。为什么？","text":"Vue源码解读学习笔记系列，逐步深入解读Vue设计和源码。 ——CafuChino 从虚拟DOM说起在使用Vue之前，Web项目最常用的库是Jquery。Jquery封装了各种常用的domApi，可以大大简化dom操作的难度，所以广受欢迎。但是无论是使用原生Js还是Jquery，当页面进行更新时依然要进行大量的DOM操作，如果要更改一个数据，可能需要逐层找到它的DOM元素，然后在对其进行更改。在开发大型项目时可能一次性要对大量DOM进行操作，这不仅会加大开发难度，还会加剧性能消耗。为什么？ DOM对象及其复杂，一个对象上有大量的属性和方法。在操作DOM对象的时候难免需要进行DOM对象和JS对象的相互转化，这一过程会造成很大的性能消耗。 DOM树发生变化或对CSS进行修改的时候，会造成重排（relayout）和重绘（repaint），这一过程会进一步加剧性能消耗。 所以要优化页面性能，可以从两个方面入手： 减少js对象和dom对象之间的转换次数 减少不必要的dom操作 那么如果可以在一开始就维护和dom树相同的js对象结构，并且只更新需要更新的位置，便可以极大的优化性能。而用js对象来表示dom的形式就被称为虚拟dom。 Snabbdom在使用Vue的时候，对于函数h()肯定不陌生。它在main.js中就曾出现过： 12345678910111213import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 而其中的h函数就来源于Snabbdom这一虚拟dom库，其特点是简洁，模块化，高度可定制，号称是最快的Virtual Dom。Vue就是采用了修改过的Snabbdom作为虚拟dom核心。 Snabbdom源码解析Snabbdom项目结构 12345678910111213141516171819202122232425262728293031323334353637383940414243├─package│ │ h.ts│ │ hooks.ts│ │ htmldomapi.ts│ │ init.ts│ │ is.ts│ │ jsx-global.ts│ │ jsx.ts│ │ thunk.ts│ │ tovnode.ts│ │ ts-transform-js-extension.cjs│ │ tsconfig.json│ │ vnode.ts│ ││ ├─helpers│ │ attachto.ts│ ││ └─modules│ attributes.ts│ class.ts│ dataset.ts│ eventlisteners.ts│ hero.ts│ module.ts│ props.ts│ style.ts│└─test │ tsconfig.json │ ├─benchmark │ core.ts │ └─unit attachto.ts attributes.ts core.ts dataset.ts eventlisteners.ts htmldomapi.ts jsx.tsx style.ts thunk.ts","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.cafuchino.cn/tags/Vue/"},{"name":"手撸源码","slug":"手撸源码","permalink":"https://www.cafuchino.cn/tags/%E6%89%8B%E6%92%B8%E6%BA%90%E7%A0%81/"}],"author":"CafuChino"},{"title":"如何用程序猿的方法打造万无一失的存稿网站(1)","slug":"如何用程序猿的方法打造万无一失的存稿网站(1)","date":"2020-07-16T18:32:33.000Z","updated":"2021-04-12T15:19:14.000Z","comments":true,"path":"2020/07/17/how-to-build-a-foolproof-site-for-manuscripts-using-the-method-of-programmers-1/","link":"","permalink":"https://www.cafuchino.cn/2020/07/17/how-to-build-a-foolproof-site-for-manuscripts-using-the-method-of-programmers-1/","excerpt":"准备采用本方案，你需要： 基础的英语水平 一台电脑 一个邮箱 一个清醒的，可以在面对黑框命令行时冷静的头脑 你需要以下软件： Git Marktext Node","text":"准备采用本方案，你需要： 基础的英语水平 一台电脑 一个邮箱 一个清醒的，可以在面对黑框命令行时冷静的头脑 你需要以下软件： Git Marktext Node 不过你无需为这些软件操心，我会把这些软件打包好提供给你。 如果你拥有一张visa信用卡，或者肯为你的这个网站花点钱，你也可以以大约$5/月的价格购买一台服务器，这将成倍的降低难度。但是本篇教程无需任何花费 安装软件安装我提供的压缩包内的三个文件，你可以按照他们后面的标号顺序安装，也可以随便什么顺序。如果不出意外，应该全部确定确定确定过去就可以了。 测试按下键盘的win+R，win键可能是一个windows小徽标，也可能写着win。在弹出的窗口中输入cmd，按下回车，应该会出现一个黑框命令行了。 以下几条命令可以测试你有没有正确安装以上软件，如果一切正常，命令的结果应该会和我的很相似： 123node -v# 结果v12.18.2 1234git# 结果(很长的一段帮助信息) 如果一切正常的话，就可以继续了。 开始首先，注册一个Github账号——这个是常规操作不多介绍了。 注册完成之后，点击首页上左侧栏用户名下面的绿色New按钮，新建一个仓库: 然后在Repository name处填入用户名.github.io，我的用户名是CafuChino，所以我填入CafuChino.github.io，效果如图所示： 点击Create repository，完成创建这个代码仓库。创建成功之后，我们点击creating a new file来随便写点什么来测试： 之后我们在文件名处填写index.html（必须是这个），在内容里写下“Hello World！”： 点击页面底部的绿色Commit new file按钮，保存这个文件。这时，回到了仓库的页面，点击右上角的settings选项： 向下滚动至GitHub Pages，你会看到你的网站已经成功部署的好消息： 我的网站地址就是https://cafuchino.github.io 了，你的应该和我类似，也是包含了你的用户名。现在让我们打开网站看看效果，点击蓝色链接，“Hello World!”已经写在了网页上： 其实到了这一步，你的网站已经搭建完成，github免费提供一个月100G的网络流量，每个小时最多10次的页面改动，对于存稿来说已经十分足够。如果你想添加一篇新的文章，可以重复之前的添加文件操作，新建一个html类型的文件，将你的文章复制进去，然后把外链发到你希望发送的平台，比如： 点击页面下方的绿色Commit new file按钮，就像之前一样，然后成功之后在刚才的地址后面加上你的html文件名： 至此，你已经学会了如何用程序猿的方法存稿，可能你会发现之前的软件一个也没用上，而且这个网站也太丑了!而之前的那些软件可以帮助你生成更好看的网页，而不用成为一个真正的 程序猿。其余的教程我将在下一篇教程中讲解。 如果你觉得这个难度可以接受，想要拥有更加绚丽的个人网页，或者拥有一个万无一失的存稿基地，欢迎在我的这篇文章下留言让我知道，我会同步更新接下来的教程内容。 愿所有写手都能自由创作！","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://www.cafuchino.cn/tags/%E6%95%99%E7%A8%8B/"},{"name":"做个程序猿","slug":"做个程序猿","permalink":"https://www.cafuchino.cn/tags/%E5%81%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%8C%BF/"}],"author":"CafuChino"},{"title":"Vue监听子组件的声明周期？","slug":"Vue监听子组件的声明周期？","date":"2020-07-07T10:31:25.000Z","updated":"2021-04-12T15:19:14.000Z","comments":true,"path":"2020/07/07/does-vue-monitor-the-life-cycle-of-child-components/","link":"","permalink":"https://www.cafuchino.cn/2020/07/07/does-vue-monitor-the-life-cycle-of-child-components/","excerpt":"2020-07-03 每日一题：Vue监听子组件的声明周期？题目1Vue父组件可以监听到子组件的生命周期吗？如果可以的话写出实现方法。","text":"2020-07-03 每日一题：Vue监听子组件的声明周期？题目1Vue父组件可以监听到子组件的生命周期吗？如果可以的话写出实现方法。 引子由于技术是在是太烂，以往写 vue项目的时候很少有自行抽象组件的时候，都是用现成的组件库，所以父子组件通讯一直到现在都不熟。正好借这个机会整理一下。 关键的$emit(成为一个无情的看文档机器) 仔细过了一遍文档，一句话总结$emit就是触发这个实例上的一个指定的事件。“事件”的范围就很宽泛了，比如@click点击就是一个事件。$emit允许我们自定义一个事件，在父组件中使用这个组件时监听，同时在子组件中自行触发，实现了子组件向父组件的通讯。 Talk is cheep. 1234567891011// 父组件中&lt;childComponent @mounted=&quot;doSomeThing&quot;&gt;...&lt;/childComponent&gt;// 子组件中mounted()&#123; this.$emit(&quot;mounted&quot;,&#123;&#x27;foo&#x27;,&#x27;bar&#x27;&#125;)&#125; 使用钩子坦白讲我也没看到hook相关的文档在哪里，好在代码很简单，直接上文档。 12// 父组件中&lt;childComponent @hook:mounted=&quot;handleChildMounted&quot;&gt;...&lt;/childComponent&gt; 其他声明周期也可以使用hook进行监听。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://www.cafuchino.cn/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.cafuchino.cn/tags/JavaScript/"}],"author":"CafuChino"},{"title":"null=?","slug":"null","date":"2020-06-18T15:57:34.000Z","updated":"2021-04-12T15:06:06.000Z","comments":true,"path":"2020/06/18/null/","link":"","permalink":"https://www.cafuchino.cn/2020/06/18/null/","excerpt":"2020-06-18 每日一题：null=？题目1234// 写出答案并解释原因console.log(null == 0);console.log(null &lt; 0);console.log(null &lt;= 0);","text":"2020-06-18 每日一题：null=？题目1234// 写出答案并解释原因console.log(null == 0);console.log(null &lt; 0);console.log(null &lt;= 0); 引子有关于几个特殊值undefinded,null,NaN还有0和空字符空数组等等是经常会拿出来出题的考点…… null到底代表了什么？ 值 null 特指对象的值未设置。它是 JavaScript 基本类型 之一，在布尔运算中被认为是falsy。值 null 是一个字面量，不像 undefined，它不是全局对象的一个属性。null 是表示缺少的标识，指示变量未指向任何对象。把 null 作为尚未创建的对象，也许更好理解。在 API 中，null 常在返回类型应是一个对象，但没有关联的值的地方使用。 题解 null只等于undefined，他不等于0，也不是0。 关系运算符中，会先尝试将运算元转Number，而==不会。 答案false,false,true","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://www.cafuchino.cn/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.cafuchino.cn/tags/JavaScript/"}],"author":"CafuChino"},{"title":"Leetcode题解-1014","slug":"Leetcode题解-1014","date":"2020-06-17T15:56:22.000Z","updated":"2021-04-12T15:06:32.000Z","comments":true,"path":"2020/06/17/leetcode-problem-solution1014/","link":"","permalink":"https://www.cafuchino.cn/2020/06/17/leetcode-problem-solution1014/","excerpt":"LeetCode每日一题 1014- 最佳观光组合给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 输入：[8,1,5,2,6]输出： 11解释： i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11","text":"LeetCode每日一题 1014- 最佳观光组合给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 输入：[8,1,5,2,6]输出： 11解释： i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 看到就很没出息的开始暴力枚举了，双重循环完整遍历，时间复杂度O(n^2)，不出意外的贴边过，差点就没通过时间限制： 12345678910111213141516/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var maxScoreSightseeingPair = function(A) &#123; let ans = 0; for(let i = 0;i&lt;A.length;i++)&#123; for(let j=i+1;j&lt;A.length;j++)&#123; const score = A[i]+A[j]+i-j; if (score&gt;ans)&#123; ans = score &#125; &#125; &#125; return ans;&#125;; 但是仔细想想这很像双指针问题，慢指针是步进的，另一个指针似乎做了很多重复的循环，可以从这里优化。原方程为A[i] + A[j] + i - j，变形一下可得(A[i]+i)+(A[j]-j)。问题迎刃而解，对于每一项来说，他的A[i]+i和A[j]-j都是固定的，所以我们只需要一次完整的遍历。在计算A[j]-j的时候，可以将A[i]+i和之前的最大值进行比较，最后相加即可。总时间复杂度为O(n): 12345678910111213/** * @param &#123;number[]&#125; A * @return &#123;number&#125; */var maxScoreSightseeingPair = function(A) &#123; var max = 0; max1 = A[0] for(var j = 1;j&lt;A.length;j++)&#123; max = Math.max(max, max1 + A[j] - j) max1 = Math.max(max1,A[j] + j) &#125; return max&#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.cafuchino.cn/tags/Leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"https://www.cafuchino.cn/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"author":"CafuChino"},{"title":"防抖/节流函数原理和实现","slug":"防抖-节流函数原理和实现","date":"2020-06-17T12:20:26.000Z","updated":"2021-04-12T15:19:14.000Z","comments":true,"path":"2020/06/17/principle-and-realization-of-antishakethrottle-function/","link":"","permalink":"https://www.cafuchino.cn/2020/06/17/principle-and-realization-of-antishakethrottle-function/","excerpt":"2020-06-17 每日一题：防抖和节流函数题目123456const debounse = (fn,delay)=&gt;&#123; // 介绍防抖函数原理，并实现&#125;const throttle = (fn,delay=500)=&gt;&#123; // 介绍节流函数原理，并实现&#125;","text":"2020-06-17 每日一题：防抖和节流函数题目123456const debounse = (fn,delay)=&gt;&#123; // 介绍防抖函数原理，并实现&#125;const throttle = (fn,delay=500)=&gt;&#123; // 介绍节流函数原理，并实现&#125; 引子第一次接触防抖和节流函数是在大一完成web学习的第一个项目时，当时需要对鼠标滚轮进行监听，但是滚轮一次会触发很多很多次事件。由此接触到了防抖和节流函数。所以如果用一句话概括一下防抖和节流函数，我的表达就是：防止一个函数被连续快速多次触发，消耗太多资源或者造成预期外的效果。 防抖函数or节流函数？防抖函数和节流函数都可以防止操作被连续触发，那么他们的区别是什么呢？ 防抖函数：在事件触发n秒后再执行回调，如果这期间再次触发，则重新计时 节流函数：在一定时间内，只能触发一次函数 倘若一个按钮绑定了某一事件，而这个按钮被连续不断的快速点击，防抖函数会等到停止点击n秒后才触发，而防抖函数每隔一段时间就会被触发一次。 所以由此可知，防抖函数和节流函数的使用场景分别为： 防抖函数：需要保证提交信息为最新的时候，比如登录，滑块等。 节流函数：需要一个较缓的频率提交一直变化的值时，如搜索推荐项。 代码实现：12345678910const debounse = (fn,delay)=&gt;&#123; let timer = null; return (...args)=&gt;&#123; //清除定时器 clearTimeout(timer) timer = setTimeout(()=&gt;&#123; fn.apply(this.args); &#125;,delay) &#125;&#125; 1234567891011121314const throttle = (fn,delay=500)=&gt;&#123; let flag = true; return (...args)=&gt;&#123; if(!flag)&#123; return; &#125; flag = false; // 开始计时 setTimeout(()=&gt;&#123; fn.applay(this,args); flag = true; &#125;,delay); &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"每日一题","slug":"每日一题","permalink":"https://www.cafuchino.cn/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.cafuchino.cn/tags/JavaScript/"}],"author":"CafuChino"},{"title":"随页面滚动淡入的动效？","slug":"随页面滚动淡入的动效？","date":"2020-06-17T05:36:23.000Z","updated":"2021-04-12T15:19:14.000Z","comments":true,"path":"2020/06/17/the-dynamic-effect-of-fading-in-as-page-scrolls/","link":"","permalink":"https://www.cafuchino.cn/2020/06/17/the-dynamic-effect-of-fading-in-as-page-scrolls/","excerpt":"这种前端动效交互感很强啊，以前使用原生的鼠标滚轮监听写过类似的功能。还要加防抖函数，麻烦的很。这段时间参考了套用的一个网页模板，找到了最简单实现这个功能的办法。 ————CafuChino 需要用到的库： Animate.css：https://daneden.github.io/animate.css/(提供写好的动效) waypoint：https://github.com/imakewebthings/waypoints(设置监听点) 在之前这样的应用中，因为不知道如何追踪页面滚动进度，所以设计成了像幻灯片切换的效果，使用的方法是原生监听鼠标滚轮，添加节流函数操作改变一个计数变量，这个计数变量的值为当前页。至于动效的实现是在翻页的同时加上一个绑定动画的类，一段时间之后再删除这个类。总而言之非常繁琐，一个简单的页面写了百余行的js专门用来操作动效。现在找到了比较简单的办法，不过思路在一些方面上依然一样。","text":"这种前端动效交互感很强啊，以前使用原生的鼠标滚轮监听写过类似的功能。还要加防抖函数，麻烦的很。这段时间参考了套用的一个网页模板，找到了最简单实现这个功能的办法。 ————CafuChino 需要用到的库： Animate.css：https://daneden.github.io/animate.css/(提供写好的动效) waypoint：https://github.com/imakewebthings/waypoints(设置监听点) 在之前这样的应用中，因为不知道如何追踪页面滚动进度，所以设计成了像幻灯片切换的效果，使用的方法是原生监听鼠标滚轮，添加节流函数操作改变一个计数变量，这个计数变量的值为当前页。至于动效的实现是在翻页的同时加上一个绑定动画的类，一段时间之后再删除这个类。总而言之非常繁琐，一个简单的页面写了百余行的js专门用来操作动效。现在找到了比较简单的办法，不过思路在一些方面上依然一样。 waypoint库：waypoint库是一个可以监听页面滚动位置的库，他监听的方式是监听某一个元素与屏幕定的距离。当设定元素与屏幕距离小于等于所设定的百分比，就会触发事件。而且还可以设定触发时的页面滚动方向，这就形成了向下滚动界面，屏幕上的元素淡入（可以使任何动效或者是任何事件）。插件的使用很简单，文档已经很完整了，所以我只记录一下我摸索的方案： 把包裹需要绑定动效的父容器设定class 为animate-box ,需要绑定动效的元素设定class为to-animate，开始动效添加class为animated，这样不仅比较容易判定元素的状态，而且可以允许父元素内有绑定动效的元素，也有不绑定的元素。 12345678910&#x2F;&#x2F;css部分.animated &#123;-webkit-animation-duration: 1s;animation-duration: 1s;-webkit-animation-fill-mode: both;animation-fill-mode: both;&#125;&#x2F;&#x2F;animate.css中有定义，可以写在页面css中方便修改.to-animate &#123;opacity: 0;&#125; 可以看出，未执行动效的元素依然存在，只是被调整成了完全透明。如果将其设为hidden，将会导致布局闪烁。 12345678&#x2F;&#x2F;js部分,使用了jq$(&#39;.animate-box&#39;).waypoint(function (direction) &#123;if (direction &#x3D;&#x3D;&#x3D; &#39;down&#39; &amp;&amp; !$(this).hasClass(&#39;animated&#39;)) &#123;$(this.element).children(&#39;.to-animate&#39;).addClass(&#39;fadeInUp animated&#39;);&#125;&#125;, &#123;offset: &#39;75%&#39;&#125;); offset指的是当元素与顶部距离的触发值，direction代表的是达到触发值的时候的方向。有一点非常重要： 这里的this指代的是监听点本身，如果直接使用this，将会获取不到其子元素，而this.element表示的才是绑定监听的元素，一定注意！ 之后页面上的元素就会在第一次滚动到那里的时候渐隐显示了，animate.css中定义了很多种的动效类型（代码里的fadeInUp就是其中定义的），想要使用哪种动效，直接添加指定的类就可以了，非常方便√当然waypoint也可以不止绑定动效，可以绑定请求，达到用户统计的作用等等；通过对用户浏览情况统计分析用户意向等。","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.cafuchino.cn/tags/%E5%89%8D%E7%AB%AF/"}],"author":"CafuChino"},{"title":"43 道检验基础的 JavaScript 面试题（1）","slug":"43 道检验基础的 JavaScript 面试题（1）","date":"2019-09-09T05:35:58.000Z","updated":"2021-04-12T15:10:12.000Z","comments":true,"path":"2019/09/09/43-basic-javascript-interview-questions-1/","link":"","permalink":"https://www.cafuchino.cn/2019/09/09/43-basic-javascript-interview-questions-1/","excerpt":"题目来源于 https://zhuanlan.zhihu.com/p/75359676 ，觉得不错。一边做一边记录。 ————CafuChino","text":"题目来源于 https://zhuanlan.zhihu.com/p/75359676 ，觉得不错。一边做一边记录。 ————CafuChino 1. 下面代码的输出是什么？123456function sayHi() &#123;console.log(name);console.log(age);var name = &quot;Lydia&quot;;let age = 21;&#125; 这道题的考点无非就是考察let的特性和var的变量提升，因为众所周知var存在变量提升。考虑不周的话可能会认为第一行会输出“Lydia”，我第一反应的时候就犯了这个错误。实则不然，即使存在变量提升，调用的时候依然没有为name赋值，所以应该返回 undefined，而age因为let声明导致死区，变量不提升，会报错 ReferenceError。 2. 下面代码的输出是什么?1234567for (var i = 0; i &lt; 3; i++) &#123;setTimeout(() =&gt; console.log(i), 1);&#125;for (let i = 0; i &lt; 3; i++) &#123;setTimeout(() =&gt; console.log(i), 1);&#125; 这道题的考点是ES6中let的块级作用域和js的事件执行机制。答案是333和012 由于JavaScript中的事件执行机制，setTimeout函数真正被执行时，循环已经走完。 由于第一个循环中的变量i是使用var关键字声明的，因此该值是全局的。 在循环期间，我们每次使用一元运算符++都会将i的值增加1。 因此在第一个例子中，当调用setTimeout函数时，i已经被赋值为3。 在第二个循环中，使用let关键字声明变量i：使用let（和const）关键字声明的变量是具有块作用域的（块是&#123;&#125;之间的任何东西）。 在每次迭代期间，i将被创建为一个新值，并且每个值都会存在于循环内的块级作用域。 3. 下面代码的输出是什么?12345678910const shape = &#123;radius: 10,diameter() &#123;return this.radius * 2;&#125;,perimeter: () =&gt; 2 * Math.PI * this.radius&#125;;shape.diameter();shape.perimeter(); 这道题的考点是箭头函数的this指代问题。与普通函数不同，箭头函数的this指代 它所在上下文（定义时的位置）的环境 。也就是说实际使用的时候，perimeter中的this指的不是shape，而是window（全局定义的变量和函数归属于window），所以会返回undefined。这里答案是20和NaN（NOT a NUMBER） 4. 下面代码的输出是什么?12+true;!&quot;Lydia&quot;; 答案是1和false，涉及到两个特性： 一元加号会把Boolean转换成数字，true为1，false为0。 字符串是真值，！为非，非真为false。 5. 哪个选项是不正确的?12345678const bird = &#123;size: &quot;small&quot;&#125;;const mouse = &#123;name: &quot;Mickey&quot;,small: true&#125;; A:mouse.bird.size B:mouse[bird.size] C:mouse[bird[&quot;size&quot;]] D: All of them are valid 选A（仔细分析过后居然选对了），开发经验！ 这道题其实考察的是JavaScript的对象键值，对象键值本质上依然是字符串，方括号里的值会被有限计算。了解这个规律之后其实很好解。A选项mouse对象没有bird键值，会返回undefined，undefined.size自然会报错 Cannot read property &quot;size&quot; of undefined 剩下两个方括号里的值都可以计算出mouse对象有的键值。 6. 下面代码的输出是什么?123456let c = &#123; greeting: &quot;Hey!&quot; &#125;;let d;d = c;c.greeting = &quot;Hello&quot;;console.log(d.greeting); 答案是”Hello”，这道题真的是个大坑，不过有开发经验的话应该会有所体会。如果单纯按照赋值思想考虑的很容易得出，d被赋值的时候依然是&#123; greeting: &quot;Hey!&quot; &#125;。所以答案是”Hey”（这是错误的！）原文作者已经写得很好了，所以直接贴上引用： 在JavaScript中，当设置它们彼此相等时，所有对象都通过引用进行交互。首先，变量c为对象保存一个值。 之后，我们将d指定为c与对象相同的引用。** 更改一个对象时，可以更改所有对象。 ** ————引自原文 7. 下面代码的输出是什么?1234567let a = 3;let b = new Number(3);let c = 3;console.log(a == b);console.log(a === b);console.log(b === c); 答案是true，false，false，难度不大，就是==只比较值，===不仅比较值还比较类型，对象和整数肯定不会相等。 8. 下面代码的输出是什么?123456789101112class Chameleon &#123;static colorChange(newColor) &#123;this.newColor = newColor;&#125;constructor(&#123; newColor = &quot;green&quot; &#125; = &#123;&#125;) &#123;this.newColor = newColor;&#125;&#125;const freddie = new Chameleon(&#123; newColor: &quot;purple&quot; &#125;);freddie.colorChange(&quot;orange&quot;); 此题考点为static，static声明的方法为静态方法，只在构造函数中存在，在子对象中不存在。freddie对象中实际没有colorChange方法，会报错TypeError。 9. 下面代码的输出是什么?123let greeting;greetign = &#123;&#125;; // Typo!console.log(greetign); （送分题？）变量不经声明直接使用归属于global或者window，为全局变量。这个打错了的案例只是声明了个空对象而已。输出也是空对象&#123;&#125;。 10. 当我们这样做时会发生什么?12345function bark() &#123;console.log(&quot;Woof!&quot;);&#125;bark.animal = &quot;dog&quot;; 这道题很有趣，正解是没什么问题，正常执行。因为js中的函数也是一种特殊的对象，加一个属性也没什么问题。而我的思路比较特殊，考虑到如果没有赋值单独读取的话应该会返回undefined，对undefined进行赋值应该不会出问题。不过还是领会函数的正确本质比较重要。 11. 下面代码的输出是什么?123456789function Person(firstName, lastName) &#123;this.firstName = firstName;this.lastName = lastName;&#125;const member = new Person(&quot;Lydia&quot;, &quot;Hallie&quot;);Person.getFullName = () =&gt; this.firstName + this.lastName;console.log(member.getFullName()); 这道题没做出来，以为还是箭头函数this指代的问题。但实际上答案应该是 TypeError 。原因引用原作者： 您不能像使用常规对象那样向构造函数添加属性。 如果要一次向所有对象添加功能，则必须使用原型。 所以在这种情况下应该这样写：Person.prototype.getFullName = function () &#123; return ${this.firstName} ${this.lastName}; &#125; 这样会使member.getFullName()是可用的，为什么样做是对的？ 假设我们将此方法添加到构造函数本身。 也许不是每个Person实例都需要这种方法。这会浪费大量内存空间，因为它们仍然具有该属性，这占用了每个实例的内存空间。 相反，如果我们只将它添加到原型中，我们只需将它放在内存中的一个位置，但它们都可以访问它！ ————引自原文 P.S.： javascript中的每个对象都有prototype属性，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。 也就是说通过protocol属性，我们可以对函数原型的属性和方法进行操作。这道题和上一题的区别是：上一道题是常规对象（一个普通的函数），而这个是个构造函数。 12. 下面代码的输出是什么?12345678910function Person(firstName, lastName) &#123;this.firstName = firstName;this.lastName = lastName;&#125;const lydia = new Person(&quot;Lydia&quot;, &quot;Hallie&quot;);const sarah = Person(&quot;Sarah&quot;, &quot;Smith&quot;);console.log(lydia);console.log(sarah); 答案是 Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125; ， undefined 。 第一个可以正常输出没有任何疑问，第二个的声明问题在于没有用new，（this真的是高频考点啊）如果没有用new，这个对象就归属于全局，此时的this是global或者window，sarah根本没有被赋值，自然是undefined。 12. 事件传播的三个阶段是什么？?答案： 在捕获阶段，事件通过父元素向下传递到目标元素。 然后它到达目标元素，冒泡开始。 案例：假设一个弹出登录窗口的页面，父元素为一个半透明遮罩，绑定点击事件为隐藏自身。子元素为登录窗口本身，上面有提交按钮。实际上当提交按钮被点击的时候，提交后父元素点击事件也被触发，这个过程叫做冒泡。 事件的对象有一个stopPropagation()方法可以阻止事件冒泡 。事件捕获是指不太具体的节点应该更早的接收到事件，而最具体的节点应该最后接收到事件 ， stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。 有点迷惑的话，有一张图解： 感觉比较有趣，有空单开一篇文章分析其机制好了。 13. 所有对象都有原型？答： 除基础对象外，所有对象都有原型。 基础对象的原型是null。 14. 下面代码的输出是什么?12345function sum(a, b) &#123;return a + b;&#125;sum(1, &quot;2&quot;); 答案为”12”，因为在这里发生了 隐式类型转换，1被隐式转换成了字符串。js中加号可以用来连接字符串，所以输出了”12” 15. 下面代码的输出是什么?1234let number = 0;console.log(number++);console.log(++number);console.log(number); 答案为：0,2,2，这道题感觉是C语言考试的相似题啊，自增放在前面是先自增再返回，放在后面是先返回再自增。所以过程是“返回=&gt;自增=&gt;自增=&gt;返回=&gt;返回” 16. 下面代码的输出是什么?12345678910function getPersonInfo(one, two, three) &#123;console.log(one);console.log(two);console.log(three);&#125;const person = &quot;Lydia&quot;;const age = 21;getPersonInfo`$&#123;person&#125; is $&#123;age&#125; years old`; 答案： [&quot;&quot;, &quot;is&quot;, &quot;years old&quot;] Lydia 21 因为如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。 其余参数获取传递到模板字符串中的表达式的值。（这样做的目的是什么？？？） 17. 下面代码的输出是什么?1234567891011function checkAge(data) &#123;if (data === &#123; age: 18 &#125;) &#123;console.log(&quot;You are an adult!&quot;);&#125; else if (data == &#123; age: 18 &#125;) &#123;console.log(&quot;You are still an adult.&quot;);&#125; else &#123;console.log(`Hmm.. You don&#x27;t have an age I guess`);&#125;&#125;checkAge(&#123; age: 18 &#125;); 这道题很有趣，因为对于对象来说，比较的不是他们的值，而是引用的地址hhhh，所以无论是相等还是严格相等都会判断false。（天坑啊）答案为：Hmm.. You don&#39;t have an age I guess，如果想比较值的话大概只能把值读取出来进行比较了。 18. 下面代码的输出是什么?12345function getAge(...args) &#123;console.log(typeof args);&#125;getAge(21); 答案为： &quot;object&quot;，扩展运算符（... args）返回一个带参数的数组。 数组是一个对象，因此typeof args返回object。 P.S.：** 对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象**之中 （是对象啊！） 20. 下面代码的输出是什么?1234567function getAge() &#123;&quot;use strict&quot;;age = 21;console.log(age);&#125;getAge(); 答案为： ReferenceError，是&quot;use strict&quot;;的锅，严格模式下不可以不经声明就使用变量，age属性不会自动变成全局变量的。 21. 下面代码的输出是什么?1const sum = eval(&quot;10*10+5&quot;); 答案为：105——即使是是字符串eval也会对表达式进行求值的。（当然需要是个表达式） 22. cool_secret可以访问多长时间?1sessionStorage.setItem(&quot;cool_secret&quot;, 123); 其实就是在问sessionStorage的存储时间，事实上，sessionStorage中的数据关闭选项卡就没有了， localStorage 中的数据将会永远存在。（TODO：写篇这个的笔记吧。） 23. 下面代码的输出是什么?1234var num = 8;var num = 10;console.log(num); 答案：10，var重复声明变量会直接覆盖。 24. 下面代码的输出是什么?1234567const obj = &#123; 1: &quot;a&quot;, 2: &quot;b&quot;, 3: &quot;c&quot; &#125;;const set = new Set([1, 2, 3, 4, 5]);obj.hasOwnProperty(&quot;1&quot;);obj.hasOwnProperty(1);set.has(&quot;1&quot;);set.has(1); 答案：true，true，false，true，对象的键值不指定字符串也是字符串，所以可以都返回true，而set不行。 25. 下面代码的输出是什么?12const obj = &#123; a: &quot;one&quot;, b: &quot;two&quot;, a: &quot;three&quot; &#125;;console.log(obj); 答案： &#123; a: &quot;three&quot;, b: &quot;two&quot; &#125; 对象中相同的键的值会被替换，但是会保留第一次出现的位置。（想的简单点不就好了吗…. ：-）） （——未完待续）","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://www.cafuchino.cn/tags/Javascript/"},{"name":"刷题","slug":"刷题","permalink":"https://www.cafuchino.cn/tags/%E5%88%B7%E9%A2%98/"}],"author":"CafuChino"},{"title":"Centos+selenium的那些坑","slug":"Centos-selenium的那些坑","date":"2019-09-04T07:10:12.000Z","updated":"2021-04-12T15:07:30.000Z","comments":true,"path":"2019/09/04//","link":"","permalink":"https://www.cafuchino.cn/2019/09/04/","excerpt":"在开发的时候遇到了大坑，本文章转自 ：https://blog.csdn.net/wkb342814892/article/details/81591394 对我有效，留档备用。","text":"在开发的时候遇到了大坑，本文章转自 ：https://blog.csdn.net/wkb342814892/article/details/81591394 对我有效，留档备用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364CentOS + Selenium 用法小结使用场景在CentOS下使用Selenium，这里的CentOS是指无GUI的Server版，其特殊性在于，没有可以供输出的显示界面，除了常见的headless方法以外，还有xvfb等工具可以使用，本文即记录我使用时碰到的一些流程及坑点。解决方案headless方法的使用以Chrome为例安装seleniumpip install selenium安装chrome-browserwget https:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;direct&#x2F;google-chrome-stable_current_x86_64.rpm --no-check-certificatesudo yum install google-chrome-stable_current_x86_64.rpm安装chromedriver：一个用来和chrome交互的接口sudo yum install chromedriver编写test.py文件test.pyfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options &#x3D; Options()chrome_options.add_argument(&#39;--headless&#39;) # 16年之后，chrome给出的解决办法，抢了PhantomJS饭碗chrome_options.add_argument(&#39;--disable-gpu&#39;)chrome_options.add_argument(&#39;--no-sandbox&#39;) # root用户不加这条会无法运行driver &#x3D; webdriver.Chrome(chrome_options&#x3D;chrome_options)for i in range(10):driver.get(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;)print(driver.title)driver.close()正常的输出就是10个&quot;百度一下，你就知道&quot;这个方案中，唯一需要注意的就是--no-sandbox参数的添加，root用户需要注意这点，但是添加以后，访问一些不安全的网站时，容易受到威胁，这需要自己权衡。Xvfb配合使用In contrast to other display servers, Xvfb performs all graphical operations in virtual memory without showing any screen output.上面这段话摘自维基百科，简单讲就是，xvfb是一个可以将屏幕的图像输出给放到虚拟内存中的东西，这样一来，在没有GUI的服务器上也能运行一些带图像输出的程序了。安装xvfbsudo yum updatesudo yum install Xvfb编写test.py文件关于启动，有两种方法可选1. xvfb-run python test.py2. Xvfb :99 &amp; # 给Xvfb开一个指定的显示端口export DISPLAY&#x3D;:99 # 告诉终端session用哪个端口test.pyfrom selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsdriver &#x3D; webdriver.Chrome()for i in range(10):driver.get(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;)print(driver.title)driver.close()这里需要注意的就是启动方法中2需要给定监视设备端口，否则chrome是没法启动的，具体表现就是无输出，然后卡住。在安装好Xvfb的前提下，还可以使用xvfb的wrapper进行调用，统一在python文件中启动，管理也更方便，使用方法如下。pip install pyvirtualdisplayfrom selenium import webdriverfrom pyvirtualdisplay import Displaydisplay &#x3D; Display(visible&#x3D;0, size&#x3D;(800,600))display.start()driver &#x3D; webdriver.Chrome()for i in range(10):driver.get(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;)print(driver.title)driver.close()————————————————版权声明：本文为CSDN博主「crazyk_wkb」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;wkb342814892&#x2F;article&#x2F;details&#x2F;81591394","categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Selenium","slug":"Selenium","permalink":"https://www.cafuchino.cn/tags/Selenium/"},{"name":"开发杂谈","slug":"开发杂谈","permalink":"https://www.cafuchino.cn/tags/%E5%BC%80%E5%8F%91%E6%9D%82%E8%B0%88/"}],"author":"CafuChino"}],"categories":[{"name":"技术","slug":"技术","permalink":"https://www.cafuchino.cn/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.cafuchino.cn/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Javascript","slug":"Javascript","permalink":"https://www.cafuchino.cn/tags/Javascript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.cafuchino.cn/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Vue","slug":"Vue","permalink":"https://www.cafuchino.cn/tags/Vue/"},{"name":"手撸源码","slug":"手撸源码","permalink":"https://www.cafuchino.cn/tags/%E6%89%8B%E6%92%B8%E6%BA%90%E7%A0%81/"},{"name":"教程","slug":"教程","permalink":"https://www.cafuchino.cn/tags/%E6%95%99%E7%A8%8B/"},{"name":"做个程序猿","slug":"做个程序猿","permalink":"https://www.cafuchino.cn/tags/%E5%81%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%8C%BF/"},{"name":"每日一题","slug":"每日一题","permalink":"https://www.cafuchino.cn/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.cafuchino.cn/tags/JavaScript/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://www.cafuchino.cn/tags/Leetcode/"},{"name":"前端","slug":"前端","permalink":"https://www.cafuchino.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"刷题","slug":"刷题","permalink":"https://www.cafuchino.cn/tags/%E5%88%B7%E9%A2%98/"},{"name":"Selenium","slug":"Selenium","permalink":"https://www.cafuchino.cn/tags/Selenium/"},{"name":"开发杂谈","slug":"开发杂谈","permalink":"https://www.cafuchino.cn/tags/%E5%BC%80%E5%8F%91%E6%9D%82%E8%B0%88/"}]}