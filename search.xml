<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>又双叒叕从头说“事件循环”</title>
      <link href="2021/04/01/shuang-%E5%95%92%E5%95%95%E5%95%92%E8%AA%AA%E6%9C%83%E8%AA%AA-event-loop-from-the-beginning/"/>
      <url>2021/04/01/shuang-%E5%95%92%E5%95%95%E5%95%92%E8%AA%AA%E6%9C%83%E8%AA%AA-event-loop-from-the-beginning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>经历了长达一个月（仍未结束）的春招提前批面试季，大大小小经历了近十次面试。在整理笔记的过程中，我发现了一些“必考点”。“事件循环”便是其中一个，虽然已经就事件循环做了一些准备，但每次回答完都有一种回答的不充分的感觉……所以不知道第多少次的从头梳理事件循环。</p></blockquote><span id="more"></span><h2 id="你了解事件循环机制么？"><a href="#你了解事件循环机制么？" class="headerlink" title="你了解事件循环机制么？"></a>你了解事件循环机制么？</h2><p>面试官们通常都是以这样一个问题展开对事件循环机制的讨论，而我之前只是机械的回答“略有了解”，然后等着面试官做进一步的提问。但是显然面试官不只是想得到一个这样的回答。所以，面试官可能想得到的是一个关于事件循环的“<strong>简要描述</strong>”或者说<strong>下定义</strong>的回答。</p><p>那么：<strong>什么是事件循环？</strong></p><p><strong>单线程</strong>机制的JavaScript引擎，为了<strong>实现异步机制</strong>，<strong>循环不断的</strong>从”任务队列”中读取事件，整个的这种运行机制称为Event Loop（事件循环）。</p><p>其中的考点已经加粗表示——</p><h3 id="为什么JavaScript采用单线程机制？"><a href="#为什么JavaScript采用单线程机制？" class="headerlink" title="为什么JavaScript采用单线程机制？"></a>为什么JavaScript采用单线程机制？</h3><p>JavaScript在设计之初是作为浏览器脚本语言使用的，其主要用途就是操作DOM。而为了避免多线程对DOM的操作产生冲突（同时对同一节点做不同修改），JavaScript被设计为单线程。</p><h3 id="为什么要实现异步机制"><a href="#为什么要实现异步机制" class="headerlink" title="为什么要实现异步机制"></a>为什么要实现异步机制</h3><p>由于JavaScript是单线程执行，假如遇到耗时的<strong>I/O</strong>操作，线程不得不停下来灯带操作完成，带来了无谓的效率下降。异步机制可以让主线程继续执行，当某个异步任务可以执行时再进入主线程执行。</p><h2 id="事件循环相关概念"><a href="#事件循环相关概念" class="headerlink" title="事件循环相关概念"></a>事件循环相关概念</h2><ol><li>执行栈：所有的同步任务都在主线程上执行，形成执行栈。</li><li>任务队列：在主进程<strong>之外</strong>，当主线程空闲(执行栈空)时，会从任务队列获取可执行的任务。</li></ol><p>所以对于事件循环，网络上其他的文章中描述：</p><blockquote><p>在JavaScript中通过回调函数在耗时操作执行完成后把相应的结果信息传递给回调函数，<strong>通知</strong>执行JavaScript代码的线程执行回调</p></blockquote><p>“通知”？如何通知？通过什么通知？“通知”这个词显然是不太准确的，同时“执行回调”这个行为，也并不是“执行耗时操作完成”这一行为直接通讯（或者说通知）所触发的。要想了解事情的问题所在，就不得不仔细了解一下浏览器<strong>渲染进程</strong>到底有哪些线程。</p><h3 id="浏览器渲染进程到底有哪些线程"><a href="#浏览器渲染进程到底有哪些线程" class="headerlink" title="浏览器渲染进程到底有哪些线程"></a>浏览器<strong>渲染进程</strong>到底有哪些线程</h3><ol><li>GUI渲染线程<ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中<strong>等到JS引擎空闲时</strong>立即被执行。</li></ul></li><li>JS引擎线程<ul><li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul></li><li>事件触发线程<ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul></li><li>定时触发器线程<ul><li>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul></li><li>异步http请求线程<ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul></li></ol><p>其中比较关键的就是“<strong>事件触发线程</strong>”，事件循环主要就是围绕着事件触发线程展开的。</p><h2 id="一段代码说基础异步"><a href="#一段代码说基础异步" class="headerlink" title="一段代码说基础异步"></a>一段代码说基础异步</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ajax1(); <span class="comment">// 假设是一个执行完会打印1的ajax请求，以下类似</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        ajax2()</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">ajax3();</span><br><span class="line">task();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果ajax请求的时间短到可以忽略，这段代码会如何执行呢？</p><ol><li>task函数被定义</li><li>ajax3函数被触发，因为是一个ajax请求，所以浏览器新开了一个异步Http请求线程进行请求，主线程继续执行</li><li>task函数开始执行，与此同时ajax3操作已经完成了，但是他的回调不会立刻执行，而是产生“<strong>状态变更事件</strong>”，这一事件触发了事件触发线程，事件触发线程将回调压入“任务队列”。</li><li>task执行（还记得吗，这一步其实和3是同时的），ajax1使得浏览器创建了一个异步Http请求线程，主线程继续执行，遇见了定时器，此时浏览器创建定时触发器线程进行计时。</li><li>与此同时，ajax1操作已经完成了，进行了类似步骤3的流程</li><li>此时执行栈已经空了，因为同步代码已经执行完了。</li><li>主进程尝试从任务队列中获取可以执行的任务，它首先获取到的是ajax3的回调，然后是ajax1的回调，所以他会先打印3，再打印1</li><li>1秒钟计时完成，定时触发器线程将回调压入任务队列</li><li>主线程获取到了任务，将任务进入执行栈</li><li>执行ajax2触发了，浏览器新开了一个异步Http请求线程进行请求，之后也是进行了类似步骤3的操作</li><li>打印结果应该是312</li></ol><h2 id="宏任务和微任务？"><a href="#宏任务和微任务？" class="headerlink" title="宏任务和微任务？"></a>宏任务和微任务？</h2><p>在事件循环中，我们不可避免的需要接触到宏任务和微任务。即使是我之前的学习中也对这方面的认识比较笼统。如果想要弄清楚宏任务和微任务，不得不引入一个新的概念——“<strong>Tick</strong>”</p><p>Event Loop中，每一次循环称为tick，每一次tick的任务如下：</p><ul><li>执行栈选择最先进入队列的宏任务（一般都是script），执行其同步代码直至结束；</li><li>检查是否存在微任务，有则会执行至微任务队列为空；</li><li>如果宿主为浏览器，可能会渲染页面；</li><li>开始下一轮tick，执行宏任务中的异步代码（setTimeout等回调）。</li></ul><p>所以——</p><h3 id="到底什么是宏任务？什么是微任务？"><a href="#到底什么是宏任务？什么是微任务？" class="headerlink" title="到底什么是宏任务？什么是微任务？"></a>到底什么是宏任务？什么是微任务？</h3><blockquote><p>ES6 规范中，microtask 称为 <code>jobs</code>，macrotask 称为 <code>task</code><br>宏任务是由宿主发起的，而微任务由JavaScript自身发起。</p></blockquote><p>之前我们提到的异步任务，比如DOM事件，比如ajax，比如定时器，都有一步“开启新线程”，可视为宿主（运行环境）发起。在没有Promise加入的时候，是并没有微任务这一概念的。但是在ES5中引入了Promise，Promise没有对应的线程，事实上也不需要开启新的线程，JavaScript引擎自己也可以开启异步任务。</p><p>所以总结一下————“由宿主发起的异步任务就是宏任务，由JS引擎发起的就是微任务”</p><p>而因为以前对这一性质认识的不是很深入，以为只有Promise和process.nextTick两种微任务，然而除了常用的这两种以外，还有一些使用的较少的微任务，比如：</p><table><thead><tr><th></th><th align="center"><strong>宏任务（macrotask）</strong></th><th align="center"><strong>微任务（microtask）</strong></th></tr></thead><tbody><tr><td>谁发起的</td><td align="center">宿主（Node、浏览器）</td><td align="center">JS引擎</td></tr><tr><td>具体事件</td><td align="center">script (可以理解为外层同步代码)，setTimeout/setInterval ，UI rendering/UI事件 ，postMessage，MessageChannel，setImmediate，I/O（Node.js）</td><td align="center">Promise，MutaionObserver， Object.observe（已废弃；<code>Proxy</code> 对象替代），process.nextTick（Node.js）</td></tr><tr><td>谁先运行</td><td align="center">后运行</td><td align="center">先运行</td></tr><tr><td>会触发新一轮Tick吗</td><td align="center">会</td><td align="center">不会</td></tr></tbody></table><h3 id="宏任务和微任务进入的是一个任务队列吗"><a href="#宏任务和微任务进入的是一个任务队列吗" class="headerlink" title="宏任务和微任务进入的是一个任务队列吗?"></a>宏任务和微任务进入的是一个任务队列吗?</h3><p>很遗憾之前的面试中这个问题答错了……（因为以前就学错了），宏任务和微任务进入的不是同一个队列</p><p><img src="https://upload-images.jianshu.io/upload_images/25750-50b8dfd7f560fe04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></p><h2 id="浏览器和Nodejs的事件循环？"><a href="#浏览器和Nodejs的事件循环？" class="headerlink" title="浏览器和Nodejs的事件循环？"></a>浏览器和Nodejs的事件循环？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><ul><li><strong>定时器</strong>：本阶段执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 的调度回调函数。</li><li><strong>待定回调</strong>：执行延迟到下一个循环迭代的 I/O 回调。</li><li><strong>idle, prepare</strong>：仅系统内部使用。</li><li><strong>轮询</strong>：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 <code>setImmediate()</code> 调度的之外），其余情况 node 将在适当的时候在此阻塞。</li><li><strong>检测</strong>：<code>setImmediate()</code> 回调函数在这里执行。</li><li><strong>关闭的回调函数</strong>：一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code>。</li></ul><p>坑：</p><ol><li>setTimeout(fn, 0)会被强制改为setTimeout(fn, 1)，所以通常情况下，即使是零延迟setTimeout也会比setImmediate先执行（除非不是timers阶段开始的）</li><li>process.nextTick永远遇到立刻执行</li></ol><h2 id="拓展-Vue中的-vm-nextTick"><a href="#拓展-Vue中的-vm-nextTick" class="headerlink" title="拓展-Vue中的 vm.$nextTick"></a>拓展-Vue中的 vm.$nextTick</h2><p><code>vm.$nextTick</code> 接受一个回调函数作为参数，用于将回调延迟到下次DOM更新周期之后执行。</p><p>这个API就是基于事件循环实现的。<br> “下次DOM更新周期”的意思就是下次微任务执行时更新DOM，而<code>vm.$nextTick</code>就是将回调函数添加到微任务中（在特殊情况下会降级为宏任务）。</p><p>因为微任务优先级太高，Vue 2.4版本之后，提供了强制使用宏任务的方法。</p><blockquote><p>vm.$nextTick优先使用Promise，创建微任务。<br> 如果不支持Promise或者强制开启宏任务，那么，会按照如下顺序发起宏任务：</p><ol><li>优先检测是否支持原生 setImmediate（这是一个高版本 IE 和 Edge 才支持的特性）</li><li>如果不支持，再去检测是否支持原生的MessageChannel</li><li>如果也不支持的话就会降级为 setTimeout。</li></ol></blockquote><p>至此事件循环知识点梳理完毕！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动实现vue-router</title>
      <link href="2021/03/15/manually-implement-vuerouter/"/>
      <url>2021/03/15/manually-implement-vuerouter/</url>
      
        <content type="html"><![CDATA[<p>所需的前置知识：</p><ul><li>插件</li><li>混入</li><li>Vue.observable()</li><li>插槽</li><li>render函数</li><li>运行时和完整版的Vue<span id="more"></span><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2></li></ul><p>Vue Router是前端路由，当路径切换时在浏览器判断当前路径，并加载对应组件</p><h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><ul><li>URL中#（HashTAG）后面的内容是路径地址</li><li>监听<code>hashchange</code>事件</li><li>根据当前路由地址找到对应组件并重新渲染</li></ul><h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><ul><li>通过history.pushState()方法改变地址栏（这一操作只改变地址栏并记录历史，并不真正跳转）</li><li>监听<code>popstate</code>事件</li><li>根据当前路由地址找到对应组件并重新渲染</li></ul><h2 id="回顾核心代码"><a href="#回顾核心代码" class="headerlink" title="回顾核心代码"></a>回顾核心代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="comment">// 注册插件</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="comment">// 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: homeComponent &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">// 创建Vue示例， 注册router对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span>h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>类图：</p><p><img src="https://i.loli.net/2021/03/15/sjAMpoH5KBq8aOg.png" alt="类图"></p><p>接下来要实现的就是这个<strong>VueRouter</strong>类</p><p><strong>属性：</strong></p><ol><li><strong>options：</strong>记录构造函数中传入的对象</li><li>**data:{current}**：需要一个响应式的对象，以便地址变化的时候路由可以响应式的更新</li><li><strong>routeMap：</strong>用于记录路由地址和组件的对应关系，会将路由规则解析到routeMap上</li></ol><p><strong>方法：</strong></p><ol><li><strong>Constructor(Options):VueRouter</strong>:构造函数</li><li><strong>_install(Vue):void</strong>:用于实现Vue的插件机制</li><li><strong>init():void</strong>:用于调用其他方法</li><li><strong>initEvent():void</strong>:用于注册popstate事件</li><li><strong>createRouteMap():void</strong>:初始化routeMap对象，建立路由组建关系</li><li><strong>initComponents(Vue):void</strong>：用于创建<router-view>，<router-link>组件</li></ol><h2 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h2><h3 id="install方法"><a href="#install方法" class="headerlink" title="install方法"></a>install方法</h3><p>install方法是Vue插件机制的关键，在vue插件系统的官方文档中讲述了插件的开发方法，其实主要的部分就是install方法需要做的事情。在这里引用一部分内容：</p><blockquote><p>:notebook_with_decorative_cover:<a href="https://cn.vuejs.org/v2/guide/plugins.html#%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6">官方文档</a></p><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">&gt;Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// 逻辑...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 2. 添加全局资源</span></span><br><span class="line">&gt;Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">&gt;bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line"><span class="comment">// 逻辑...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;...</span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 3. 注入组件选项</span></span><br><span class="line">&gt;Vue.mixin(&#123;</span><br><span class="line">&gt;created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 逻辑...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;...</span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 4. 添加实例方法</span></span><br><span class="line">&gt;Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">&gt;<span class="comment">// 逻辑...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>整理一下我们的手写实现思路：</p><ol><li>判断当前插件是否已经被安装（Vue的插件只能安装一次）</li><li>添加全局资源</li><li>注入组件选项</li><li>添加实例方法</li></ol><h4 id="判断安装状态"><a href="#判断安装状态" class="headerlink" title="判断安装状态"></a>判断安装状态</h4><p>显然我们需要一个变量来记录插件是否被安装了，局部变量显然无法记录状态；全局变量会引入外部依赖，显然也不妥，所以鉴于install方法是一个静态方法，其上可以带一个属性。这个属性会长期保持，并可随时访问，很适合这种需求，所以我们只需要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vue.use的时候调用的函数，传入Vue的构造实例， 和可选的选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>Vue Vue的构造实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>options 选项对象（可选）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">install</span>(<span class="params">Vue, options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断当前插件是否已经被安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) <span class="keyword">return</span>;</span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2.把Vue构造函数记录到全局变量</span></span><br><span class="line">    <span class="comment">// 3.把创建Vue实例时候传入的router对象注入到Vue实例上</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注入组件选项"><a href="#注入组件选项" class="headerlink" title="注入组件选项"></a>注入组件选项</h4><p>虽然在use的时候已经传入了Vue的构造实例了，但是我们不能通过prototype直接在所有的Vue实例上挂载实例方法。原因是install是静态方法，调用的时候其this指向的是VueRouter类，而不是Vue实例。所以此处必须使用<code>Vue.mixin()</code>来进行注入，这样每一个Vue实例在指定的生命周期钩子被触发的时候都会执行混入的内容，从而达到在每一个Vue实例上注入的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vue.use的时候调用的函数，传入Vue的构造实例， 和可选的选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>Vue Vue的构造实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>options 选项对象（可选）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">install</span>(<span class="params">Vue, options</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断当前插件是否已经被安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) <span class="keyword">return</span>;</span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2.把Vue构造函数记录到全局变量(组件内全局，以方便以下逻辑调用)</span></span><br><span class="line">    _Vue = Vue</span><br><span class="line">    <span class="comment">// 3.把创建Vue实例时候传入的router对象注入到Vue实例上</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 只需要给vue实例挂载，而不需要给组件挂载，组件是没有$options的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">          <span class="comment">// 此时this的指向就不再是VueRouter了，而是实例本身了</span></span><br><span class="line">          _Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数只需要初始化三个属性，并且将data设为响应式，Vue为我们提供了<code>Vue.observable()</code>方法，可以直接将其转化为响应式的对象，所以构造函数我们可以如下实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options;</span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.data = _Vue.observable(&#123;</span><br><span class="line">      <span class="comment">// 当前地址，默认为根</span></span><br><span class="line">      current: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="createRouteMap方法"><a href="#createRouteMap方法" class="headerlink" title="createRouteMap方法"></a>createRouteMap方法</h3><p>这一方法可以将Options中传入的路由规则转化为路由键值对的形式，键是路由的地址，值是对应的组件。这样路由变化时，就可以快速的找到对应的组件并将其渲染出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">createRouteMap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历所有的路由规则解析并构造键值对</span></span><br><span class="line">  <span class="built_in">this</span>.options.routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.routeMap[route.path] = route.component</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initComponents方法和init方法"><a href="#initComponents方法和init方法" class="headerlink" title="initComponents方法和init方法"></a>initComponents方法和init方法</h3><p>顾名思义，这个函数用于初始化跟路由相关的两个组件：<router-link>，<router-view>。<router-link>组件接受一个字符串类型的参数<code>to</code>并且标签中的内容会被渲染成a标签。与此同时我们还可以使用init方法将之前的<code>createRouteMap</code>和这一方法包装一下，方便统一调用。</p><p>至此完整代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vue.use的时候调用的函数，传入Vue的构造实例， 和可选的选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>Vue Vue的构造实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>options 选项对象（可选）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// eslint-disable-next-line no-unused-vars</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">install</span>(<span class="params">Vue, options</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断当前插件是否已经被安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) <span class="keyword">return</span>;</span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2.把Vue构造函数记录到全局变量(组件内全局，以方便以下逻辑调用)</span></span><br><span class="line">    _Vue = Vue</span><br><span class="line">    <span class="comment">// 3.把创建Vue实例时候传入的router对象注入到Vue实例上</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 只需要给vue实例挂载，而不需要给组件挂载，组件是没有$options的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">          <span class="comment">// 此时this的指向就不再是VueRouter了，而是实例本身了</span></span><br><span class="line">          _Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br><span class="line">          <span class="built_in">this</span>.$options.router.init()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options;</span><br><span class="line">    <span class="built_in">this</span>.routeMap = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.data = _Vue.observable(&#123;</span><br><span class="line">      <span class="comment">// 当前地址，默认为根</span></span><br><span class="line">      current: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.createRouteMap();</span><br><span class="line">    <span class="built_in">this</span>.initComponents(_Vue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">createRouteMap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历所有的路由规则解析并构造键值对</span></span><br><span class="line">    <span class="built_in">this</span>.options.routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routeMap[route.path] = route.component</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">initComponents</span>(<span class="params">Vue</span>)</span>&#123;</span><br><span class="line">    Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">      props:&#123;</span><br><span class="line">        to: <span class="built_in">String</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      template:<span class="string">&#x27;&lt;a :href=&quot;to&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步，路由就可以正常跳转了（虽然还不能显示），其实核心工作就是进行了一步解析，一步混入挂载，一步声明router-link（实际上就是个a标签）。如果你熟悉vue的源码或原理，对render中的h函数必然不会感到陌生了。但是其实这个时候的跳转不是我们想要的跳转，我们想要的跳转并不是真正的跳转，而是只改变地址栏和渲染的组件，所以我们必须进一步阻止a标签的默认行为，并调用<code>pushState</code>api来改变地址栏：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">initComponents</span>(<span class="params">Vue</span>)</span> &#123;</span><br><span class="line">    Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        to: <span class="built_in">String</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">          attrs: &#123;</span><br><span class="line">            href: <span class="built_in">this</span>.to</span><br><span class="line">          &#125;,</span><br><span class="line">          on: &#123;</span><br><span class="line">            click: <span class="built_in">this</span>.clickHandler</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [<span class="built_in">this</span>.$slots.default])</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">clickHandler</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">          history.pushState(&#123;&#125;, <span class="string">&#x27;&#x27;</span>, <span class="built_in">this</span>.to);</span><br><span class="line">          <span class="built_in">this</span>.$router.data.current = <span class="built_in">this</span>.to</span><br><span class="line">          e.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经过一番修改，我们成功的阻止了默认行为，并且通过api改变了地址栏内容，修改了current响应式参数的值。不过这个时候组件还不能被渲染，因为我们还没有声明<code>router-view</code>组件。render函数也可以直接帮助我们渲染一个组件。既然current是响应式的，当current发生变化的时候，渲染的内容自然而然的就会发生变化了。唯一的问题在于，在render函数中，this的指向是指向该实例内部的this而不是VueRouter对象的，所以我们不可以在这里直接使用this。带有<code>router-view</code>组件的完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vue.use的时候调用的函数，传入Vue的构造实例， 和可选的选项</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>Vue Vue的构造实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>options 选项对象（可选）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-unused-vars</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">install</span>(<span class="params">Vue, options</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.判断当前插件是否已经被安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) <span class="keyword">return</span>;</span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2.把Vue构造函数记录到全局变量(组件内全局，以方便以下逻辑调用)</span></span><br><span class="line">    _Vue = Vue</span><br><span class="line">    <span class="comment">// 3.把创建Vue实例时候传入的router对象注入到Vue实例上</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 只需要给vue实例挂载，而不需要给组件挂载，组件是没有$options的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">          <span class="comment">// 此时this的指向就不再是VueRouter了，而是实例本身了</span></span><br><span class="line">          _Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br><span class="line">          <span class="built_in">this</span>.$options.router.init()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options;</span><br><span class="line">    <span class="built_in">this</span>.routeMap = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.data = _Vue.observable(&#123;</span><br><span class="line">      <span class="comment">// 当前地址，默认为根</span></span><br><span class="line">      current: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.createRouteMap();</span><br><span class="line">    <span class="built_in">this</span>.initComponents(_Vue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">createRouteMap</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有的路由规则解析并构造键值对</span></span><br><span class="line">    <span class="built_in">this</span>.options.routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routeMap[route.path] = route.component</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">initComponents</span>(<span class="params">Vue</span>)</span> &#123;</span><br><span class="line">    Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        to: <span class="built_in">String</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">          attrs: &#123;</span><br><span class="line">            href: <span class="built_in">this</span>.to</span><br><span class="line">          &#125;,</span><br><span class="line">          on: &#123;</span><br><span class="line">            click: <span class="built_in">this</span>.clickHandler</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [<span class="built_in">this</span>.$slots.default])</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">clickHandler</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">          history.pushState(&#123;&#125;, <span class="string">&#x27;&#x27;</span>, <span class="built_in">this</span>.to);</span><br><span class="line">          <span class="built_in">this</span>.$router.data.current = <span class="built_in">this</span>.to</span><br><span class="line">          e.preventDefault()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    Vue.component(<span class="string">&#x27;router-view&#x27;</span>, &#123;</span><br><span class="line">      <span class="function"><span class="title">render</span>(<span class="params">h</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> component = self.routeMap[self.data.current];</span><br><span class="line">        <span class="keyword">return</span> h(component)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就完美的实现了所有功能。除了最后一个问题——<strong>当我们点击浏览器后退时会怎么样</strong>，当然什么都不会发生。因为地址栏虽然发生了变化，但是current没有发生变化，current没有发生变化组件就不会变化，所以什么都不会发生，而如果我们希望组件也变化，那么便需要监听popstate事件。</p><h3 id="initEvent方法"><a href="#initEvent方法" class="headerlink" title="initEvent方法"></a>initEvent方法</h3><p>这一部分很简单，我们只需要添加一个全局的popstate的事件监听，并将地址赋值给current即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">initEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;popstate&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.data.current = <span class="built_in">window</span>.location.pathname</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，不要忘记在<code>init()</code>函数中调用一下这个初始化函数，这样我们才算是真正的自己实现了vue-router。</p><p>完整代码参见<a href="https://github.com/CafuChino/Awesome-myEverything/tree/main/vue-router/history">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程原理(3)</title>
      <link href="2021/01/28/principles-of-functional-programming-3/"/>
      <url>2021/01/28/principles-of-functional-programming-3/</url>
      
        <content type="html"><![CDATA[<h2 id="00-接上篇"><a href="#00-接上篇" class="headerlink" title="00-接上篇"></a>00-接上篇</h2><p>说起函数式编程，我觉得与其专注于lodash或者rambda这些实现的函数，我可能更倾向从moment入手。因为他是我用过最多也是最接近函数式编程的库。在我还对js和函数式编程不甚了解的时候，我曾思考过一个问题：<strong>为什么moment.js的各个功能函数可以以几乎任何次序无限的链式调用下去？</strong> 最后我得到的认为最满意的结果是：<strong>每一个功能函数都是一个对象上的方法，每一个功能方法的返回值都是这个对象</strong> 。虽然这个想法不甚准确，但是其实已经比较接近函数式编程的本质了。或者说，接近函数式编程的具体实现了。那就是——<strong>“函子”</strong></p><span id="more"></span><h2 id="01-函子——一份带原材料的工具箱"><a href="#01-函子——一份带原材料的工具箱" class="headerlink" title="01-函子——一份带原材料的工具箱"></a>01-函子——一份带原材料的工具箱</h2><p>如果要我不准确但是形象的概括<strong>什么是函子</strong>，我会把它描述成一个带有原材料的工具箱。</p><p>比如说一个最基础的<code>Functor</code>函子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个容器，包裹一个值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"><span class="comment">// of 静态方法，可以省略 new 关键字创建对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Container(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>._value = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map 方法，传入变形关系，将容器里的每一个值映射到另一个容器</span></span><br><span class="line">map (fn) &#123;</span><br><span class="line"><span class="keyword">return</span> Container.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">Container.of(<span class="number">3</span>)</span><br><span class="line">.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</span><br><span class="line">.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br></pre></td></tr></table></figure><p>可以看出，我们的函子其实什么都没有做，他只是提供了一个创建自身的静态方法，并且提供了返回“这个容器”的方法。看到这我们就可以迫不及待的来实现一下Moment了，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moment</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">of</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Moment(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._value = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">format</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 一些用来格式化的操作</span></span><br><span class="line">        <span class="keyword">return</span> Moment.of(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，我们想调用多少次<code>.format()</code>方法都可以，因为无论进行多少次format，返回的对象上都有format这个方法。</p><p>（当然，Moment内部可能不是这么设计的，这也不是函子的绝对正确用法，不过这个可以很好的体现<code>of</code>这个操作的思想）</p><p>很显然，函子就是链式调用的起源，函子这种返回自身对象的思路使得我们可以近乎无限的链式调用下去。</p><h3 id="MayBe-函子"><a href="#MayBe-函子" class="headerlink" title="MayBe 函子"></a>MayBe 函子</h3><p>当然我们的程序无论如何都不可能完全排除副作用，我们必须接受不确定的输入，或者是进行某些对外界环境的操作。如果一定要要求没有副作用，那么几乎无法使用函数式编程。所以我们要做的事情就是把副作用控制在可以接受的范围。比如，我们在接受外界输入或者是进行io的时候，经常可能遇到空，这就可能存在副作用。Maybe函子可以对外界为空的时候做出处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MayBe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MayBe(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果对空值变形的话直接返回 值为 null 的函子</span></span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isNothing() ? MayBe.of(<span class="literal">null</span>) : MayBe.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">  isNothing () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value === <span class="literal">null</span> || <span class="built_in">this</span>._value === <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入具体值</span></span><br><span class="line">MayBe.of(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">.map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line"><span class="comment">// 传入 null 的情况</span></span><br><span class="line">MayBe.of(<span class="literal">null</span>)</span><br><span class="line">.map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</span><br><span class="line"><span class="comment">// =&gt; MayBe &#123; _value: null &#125;&#123;</span></span><br></pre></td></tr></table></figure><p>可以看出，Maybe函子相较于普通函子，多做的一件事就是当传入空的时候直接返回空，而不进行函数运算。这就把副作用控制在了可以接受的范围，但是这样只要中间异步出现空，之后的结果就都是空了。</p><h3 id="Either-函子"><a href="#Either-函子" class="headerlink" title="Either 函子"></a>Either 函子</h3><p>异常也会使函数变的不是纯函数（出现了与预期不同的结果），而Either函子可以用于分支判断，控制异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Left</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Left(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  map (fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Right</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Right(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Right.of(fn(<span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，Either函子是一个普通的Functor配合一个什么都不会做只会返回自身的函子，这样就可以将错误传递下去。</p><h3 id="IO函子"><a href="#IO函子" class="headerlink" title="IO函子"></a>IO函子</h3><p>我们之前有提到过，副作用的一个主要的来源就是IO操作，IO操作可能会带来各种不同的副作用。而这类操作通常都是程序的核心任务类型之一（比如操作数据库，redis，文件等等）。我们不能消除副作用，但是可以控制副作用——通过把分部出现的副作用一次性的执行的方法。这样程序只需要负责纯函数的部分就可以了，副作用可以交给用户来处理。简单的来说就是：把会产生副作用的操作合并在一起执行（使用之前提到过的函数聚合）、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span> (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = fn</span><br><span class="line">  &#125;</span><br><span class="line">  map (fn) &#123;</span><br><span class="line">  <span class="comment">// 把当前的 value 和 传入的 fn 组合成一个新的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IO(fp.flowRight(fn, <span class="built_in">this</span>._value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> io = IO.of(process).map(<span class="function"><span class="params">p</span> =&gt;</span> p.execPath)</span><br><span class="line"><span class="built_in">console</span>.log(io._value())</span><br></pre></td></tr></table></figure><h3 id="Task函子"><a href="#Task函子" class="headerlink" title="Task函子"></a>Task函子</h3><p>异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示。folktale是一个标准的函数式编程库，和 lodash、ramda 不同的是，他没有提供很多功能函数。只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task、Either、MayBe 等<br>folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的函子，这里以 2.3.2 来演示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> io = IO.of(process).map(<span class="function"><span class="params">p</span> =&gt;</span> p.execPath)</span><br><span class="line"><span class="built_in">console</span>.log(io._value())</span><br><span class="line"><span class="keyword">const</span> &#123; compose, curry &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/core/lambda&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; toUpper, first &#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="comment">// 第一个参数是传入函数的参数个数</span></span><br><span class="line"><span class="keyword">let</span> f = curry(<span class="number">2</span>, <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;)</span><br><span class="line">f(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">f(<span class="number">3</span>)(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 函数组合</span></span><br><span class="line"><span class="keyword">let</span> f = compose(toUpper, first)</span><br><span class="line">f([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> &#123; task &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/concurrency/task&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> task(<span class="function"><span class="params">resolver</span> =&gt;</span> &#123;</span><br><span class="line">fs.readFile(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (err) resolver.reject(err)</span><br><span class="line">resolver.resolve(data)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 run 执行</span></span><br><span class="line">readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">.map(split(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">.map(find(<span class="function"><span class="params">x</span> =&gt;</span> x.includes(<span class="string">&#x27;version&#x27;</span>)))</span><br><span class="line">.run().listen(&#123;</span><br><span class="line">onRejected: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;,</span><br><span class="line">onResolved: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Monad函子"><a href="#Monad函子" class="headerlink" title="Monad函子"></a>Monad函子</h3><p>在JavaScript的Class中并没有提供严格的“私有属性”特性，我们只能通过在属性名前面加上<code>_</code>下划线来约定这个属性是一个私有属性，或是使用Symbol数据类型实现私有属性。当我们需要获取函子中的<code>_value</code>时直接获取“私有属性”显然是不符合约定的。正如我们使用<code>of</code>函数避免使用new来创建新对象一样，我们也可以通过<code>join</code>函数来返回<code>_value</code>来避免直接获取私有属性。一个函子如果具有join和of两个方法并且遵守一些规律就是一个Monad函子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="comment">// IO Monad</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">of</span> (x) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title">constructor</span> (<span class="params">fn</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>._value = fn</span><br><span class="line">&#125;</span><br><span class="line">map (fn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> IO(fp.flowRight(fn, <span class="built_in">this</span>._value))</span><br><span class="line">&#125;</span><br><span class="line">join () &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>._value()</span><br><span class="line">&#125;</span><br><span class="line">flatMap (fn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.map(fn).join()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">.map(fp.toUpper)</span><br><span class="line">.flatMap(print)</span><br><span class="line">.join()</span><br></pre></td></tr></table></figure><h2 id="02-总结"><a href="#02-总结" class="headerlink" title="02-总结"></a>02-总结</h2><p>有关函数式编程的笔记就记录到这里。概括一下函数式编程的一些知识点：</p><ul><li><p>纯函数对于相同的输入总有相同的输出，而且不会带来副作用</p></li><li><p>柯里化就是把一个多元纯函数变成一个一元纯函数</p></li><li><p>柯里化的原理就是暂存传入的参数，等到参数全部传入再执行，实现原理为闭包</p></li><li><p>柯里化的目的是便于函数组合</p></li><li><p>函数组合的目的是消除洋葱代码，将执行过程进行封装</p></li><li><p>可以利用函子实现函数式编程</p></li><li><p>函子的作用是实现链式调用和控制副作用</p></li><li><p>副作用不可能被消除，但可以被控制</p></li></ul><p>（完）</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程原理(2)</title>
      <link href="2021/01/26/principles-of-functional-programming-2/"/>
      <url>2021/01/26/principles-of-functional-programming-2/</url>
      
        <content type="html"><![CDATA[<h2 id="00-接上篇"><a href="#00-接上篇" class="headerlink" title="00-接上篇"></a>00-接上篇</h2><p>在上一篇中主要记录了函数柯里化的基本概念和手动实现，当然如果在每一个项目中都手动实现一遍柯里化显然是不方便的。其次，函数柯里化在函数式编程中具体有哪些应用模式呢？本篇将主要讲述柯里化的使用和函数式编程的应用。</p><span id="more"></span><h2 id="01-Lodash中的柯里化功能"><a href="#01-Lodash中的柯里化功能" class="headerlink" title="01-Lodash中的柯里化功能"></a>01-Lodash中的柯里化功能</h2><p><code>lodash</code>是一个一致性、模块化、高性能的 JavaScript 实用工具库。在其内部将我们生产和开发中的许多常用功能抽象成了各种函数以方便调用（虽然他们不一定都是纯函数），其中便提供了<code>curry</code>和<code>curryRight</code>方法，这一方法可以帮助我们将函数柯里化。其中<code>curry</code>方法与我们自己实现的函数使用方法差异不多，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curried = _.curry(abc);</span><br><span class="line"></span><br><span class="line">curried(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">curried(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">curried(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Curried with placeholders.</span></span><br><span class="line">curried(<span class="number">1</span>)(_, <span class="number">3</span>)(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>而<code>curryRight</code>除了 会生成柯里化之后的函数之外，其传递参数的顺序是由后向前。</p><h2 id="02-初步总结柯里化"><a href="#02-初步总结柯里化" class="headerlink" title="02-初步总结柯里化"></a>02-初步总结柯里化</h2><p>至此，单纯关于柯里化的内容已经完毕，柯里化的优点和作用已然明了：</p><p><strong>柯里化可以通过闭包的方式实现生成一个“缓存了一部分参数的函数”从而使我们能够无压力的抽象细粒度的函数而不必担心传入的参数过多的不便。</strong></p><p>但是柯里化显然不止是开发上多传一个或者少传一个参数的问题，柯里化的核心其实是<strong>将一个多元函数转换成一个一元函数</strong>，而为什么要组合成一元函数呢？答案是：<strong>函数组合</strong></p><h2 id="03-函数组合"><a href="#03-函数组合" class="headerlink" title="03-函数组合"></a>03-函数组合</h2><p>首先假设我们需要设计这样一个函数，这个函数的目的是获取数组的最后一个元素并且转换为大写字母，如果应用我们之前所涉及的柯里化和纯函数，我们理所当然的会写出这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_.toUpper(_.first(_.reverse(array)))</span><br></pre></td></tr></table></figure><p>这种代码虽然可以正常并且顺利的获得我们想要的结果，但是这种“洋葱代码”的层层嵌套如果层级太多就会不利于代码的编写和维护。所以在这种情况我们就不再适合嵌套使用，而是使用“函数组合”：</p><p><strong>函数组合可以让我们把细粒度的函数重新组合生成一个新的函数</strong></p><p>函数组合的思想是一种由<strong>从内到外</strong>编写格式到<strong>依次执行</strong>思路的转变，他有点像pipeline，但是完全不同，不过这并不能阻止你将他想像成一个管道：</p><p>如果说一个纯函数是一个完整的管道，接受一个输入，并提供一个输出，就像：</p><p><img src="https://chinocdn.cafuchino.cn/pic/20210126140173.png"></p><p>那么使用纯函数的函数组合就像是把一个复杂的多个管道转变成一个个连接在一起的细分小管道：</p><p><img src="https://chinocdn.cafuchino.cn/pic/20210126140114.png"></p><p>到这之前的铺垫就都讲得通了，之所以要将函数进行柯里化，是因为需要将多元函数转变为一元函数。而需要一元纯函数的原因，就是在具体组合应用的时候方便进行函数组合。函数组合思想的便利之处就在于，我们可以放心的尽可能细粒度的抽象函数而不必担心调用时过于复杂的问题。我们在应用的时候只要拿出足够细粒度的函数“积木”进行进一步的功能通过组合函数进行整合即可（<strong>需要注意的是组合函数的执行顺序是从右到左</strong>）。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">f, g</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> f(g(x))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.reverse()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从右到左运行</span></span><br><span class="line"><span class="keyword">let</span> last = compose(first, reverse)</span><br><span class="line"><span class="built_in">console</span>.log(last([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure><p>看过代码，相信“从右到左”这个似乎很反常规的规则的原因也已经明了了，虽然我们传参的顺序是<code>(f, g)</code>，但是只要想像一下内部的“洋葱代码”，就可得知其实洋葱的最内部是”g“，是内部的函数先执行。</p><p>而这样的解决方式显然还是不够“优雅”，你可能会发现其实只是把洋葱代码换了个地方写了而已，而且这种函数组合只能处理两个函数的情况。如果我们需要使用多个函数的组合又该怎么办呢？<strong>Lodash为我们提供了解决方案</strong><code>flow()</code>和<code>flowRight()</code>，其中flowRight便是从右到左执行的组合方式。这种方式在实际应用中会使用的更多一点（因为他能更好的帮助我们去想像其中的洋葱函数？？？）。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> toUpper = <span class="function"><span class="params">s</span> =&gt;</span> s.toUpperCase()</span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reverse()</span><br><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> f = _.flowRight(toUpper, first, reverse)</span><br><span class="line"><span class="built_in">console</span>.log(f([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>可以看出我们很优雅的将三个细粒度的纯函数进行了组合形成了一个全新的函数<code>f()</code>，比洋葱代码要好维护得多了。</p><p><strong>以下是面试专用手写一切时间！！！</strong></p><p>在面试的的时候如果面试官问起函数组合是如何实现的，我们可以给出这样一个思路：</p><ul><li><p>获取传入所有参数的伪数组</p></li><li><p>将其反转（因为我们需要从右向左依次执行）</p></li><li><p>依次组合函数，并将前一个函数的返回值作为后一个函数的参数</p></li><li><p>返回生成的函数</p></li></ul><p>如果面试官问：那么用代码如何实现呢，我们便可以仅用一行代码展现自己优秀的编程水平（并不），如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">value</span> =&gt;</span> fns.reverse().reduce(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span></span><br><span class="line">fn(acc), value)</span><br></pre></td></tr></table></figure><p>在这行代码中我们依然使用了…参数的这样的剩余参数用法以获取所有的参数构成的伪数组。之后我们简单的将其简单的<code>reverse()</code>。然后调用了<code>reduce()</code>方法。（这里值得好好说一下）</p><p><code>reduce</code>函数是一个累加器，它接受一个函数作为参数，并且返回数组中每一个元素通过这个函数进行累加之后的值。这样说可能比较抽象，我们可以用数组求和来举个栗子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">65</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">total, num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + num;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML = numbers.reduce(getSum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reduce</code>函数会将累加中间结果作为第一个参数，数组项作为第二个参数传入提供的函数，从而返回最终结果。在这个案例中我们会对这个数组中的每一项进行求和。</p><p>回到我们手写的<code>compose</code>函数，我们的函数接受一系列参数，返回的内容是一个接受一个<code>value</code>参数的函数，函数的内部会累加执行当前函数并且将之前函数的结果作为参数，当然还会传入我们传入的value作为初始参数。翻译成更好理解的方式就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function"><span class="params">value</span> =&gt;</span> fns.reverse().reduce(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span></span><br><span class="line">fn(acc), value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fns.reverse().reduce(<span class="function">(<span class="params">acc, fn</span>)=&gt;</span>&#123;<span class="keyword">return</span> fn(acc)&#125;, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你学废了吗？</p><h2 id="04-调试组合函数"><a href="#04-调试组合函数" class="headerlink" title="04-调试组合函数"></a>04-调试组合函数</h2><p>调试组合函数…..就是在调用的一串函数中间插一个柯里化过的额外函数，然后将接收到的中间参数原样返回传递下去就可以了….（其实可能不如打个断点？）</p><p>示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> trace = _.curry(<span class="function">(<span class="params">tag, v</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(tag, v)</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> split = _.curry(<span class="function">(<span class="params">sep, str</span>) =&gt;</span> _.split(str, sep))</span><br><span class="line"><span class="keyword">const</span> join = _.curry(<span class="function">(<span class="params">sep, array</span>) =&gt;</span> _.join(array, sep))</span><br><span class="line"><span class="keyword">const</span> map = _.curry(<span class="function">(<span class="params">fn, array</span>) =&gt;</span> _.map(array, fn))</span><br><span class="line"><span class="keyword">const</span> f = _.flowRight(join(<span class="string">&#x27;-&#x27;</span>), trace(<span class="string">&#x27;map 之后&#x27;</span>), map(_.toLower),</span><br><span class="line">trace(<span class="string">&#x27;split 之后&#x27;</span>), split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="string">&#x27;NEVER SAY DIE&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="05-Point-free"><a href="#05-Point-free" class="headerlink" title="05-Point free"></a>05-Point free</h2><p>其实前面几千字的铺垫都是为了这一点…….</p><p>Point free 编程顾名思义就是他可以省去一些东西，而被free的point是什么呢？你可以这样理解：</p><p><strong>如果我们清楚的知道一个公式的计算过程，那么我们即使不提供任何数据，就可以表达出这个公式，并且确信他能达到预期的结果。</strong></p><p>而这就需要纯函数，柯里化，函数组合等概念作为前提：</p><ul><li><p>如果一个函数会产生副作用，那么就无法确定预期结果（是否为纯函数）</p></li><li><p>如果一个函数是多元函数，那么就必须额外提供参数（不需要提供任何数据）</p></li><li><p>如果一个函数可以被组合，那么他就可以用来表示程序的计算过程（表达出一个公式）</p></li></ul><p>PointFree这一特点通常用来封装一个底层函数，这样我们无需了解其内部的运作流程，只要调用这个函数就可以了，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello World =&gt; hello_world</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">word</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> word.toLowerCase().replace(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Point Free</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> f = fp.flowRight(fp.replace(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;_&#x27;</span>), fp.toLower)</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="string">&#x27;Hello World&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> firstLetterToUpper = fp.flowRight(join(<span class="string">&#x27;. &#x27;</span>),</span><br><span class="line">fp.map(fp.flowRight(fp.first, fp.toUpper)), split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(firstLetterToUpper(<span class="string">&#x27;world wild web&#x27;</span>))</span><br><span class="line"><span class="comment">// =&gt; W. W. W</span></span><br></pre></td></tr></table></figure><h2 id="06-函数式编程相关库"><a href="#06-函数式编程相关库" class="headerlink" title="06-函数式编程相关库"></a>06-函数式编程相关库</h2><p>lodash/fp</p><ul><li><p>lodash 的 fp 模块提供了实用的对函数式编程友好的方法</p></li><li><p>提供了不可变 auto-curried iteratee-first data-last 的方法</p></li></ul><p>（意思就是所有的函数都已经柯里化过，如果同时传参后传数据）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lodash 模块</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line">_.map([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], _.toUpper)</span><br><span class="line"><span class="comment">// =&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">_.map([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="comment">// =&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">_.split(<span class="string">&#x27;Hello World&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment">// lodash/fp 模块</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line">fp.map(fp.toUpper, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">fp.map(fp.toUpper)([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">fp.split(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">fp.split(<span class="string">&#x27; &#x27;</span>)(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> f = fp.flowRight(fp.join(<span class="string">&#x27;-&#x27;</span>), fp.map(_.toLower), fp.split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="string">&#x27;NEVER SAY DIE&#x27;</span>))</span><br></pre></td></tr></table></figure><blockquote><p>本系列/专栏为<strong>拉勾教育-大前端高薪训练营</strong>学习笔记，内容为本系列课程的讲授内容、亮点题目分析、重点难点的总结、以及个人的体会。个人感觉拉勾教育比体验过的其他教育平台要更好一点。老师讲授的内容比较全面，相对于自学可以节省很多不必要的走弯路的时间，可以更快的使自己在技术上系统的有所提高。同时随堂测的题目也很用代表性，老师跟进解答很快，推荐和我一样在自学路上遇到瓶颈或者找不到进一步学习方向的同学尝试一下。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程原理(1)</title>
      <link href="2021/01/22/principles-of-functional-programming-1/"/>
      <url>2021/01/22/principles-of-functional-programming-1/</url>
      
        <content type="html"><![CDATA[<h2 id="00-序"><a href="#00-序" class="headerlink" title="00 - 序"></a>00 - 序</h2><p>本系列/专栏为<strong>拉勾教育-大前端高薪训练营</strong>学习笔记，内容为本系列课程的讲授内容、亮点题目分析、重点难点的总结、以及个人的体会。个人感觉拉勾教育比体验过的其他教育平台要更好一点。老师讲授的内容比较全面，相对于自学可以节省很多不必要的走弯路的时间，可以更快的使自己在技术上系统的有所提高。同时随堂测的题目也很用代表性，老师跟进解答很快，推荐和我一样在自学路上遇到瓶颈或者找不到进一步学习方向的同学尝试一下。</p><span id="more"></span><h2 id="01-说说函数式编程"><a href="#01-说说函数式编程" class="headerlink" title="01 - 说说函数式编程"></a>01 - 说说函数式编程</h2><p>之前阅读一些经验丰富的开发者的源码，或者使用某些库的时候。我经常发现，有的代码可以一直“点下去”。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maybe</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">badCode</span>(<span class="params">para</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = sth.doSth(para)</span><br><span class="line">    temp = sth.doAnother(temp)</span><br><span class="line">    <span class="keyword">return</span> sth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// but ?</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elegentCode</span>(<span class="params">para</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sth(para).doSth().doAnother()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，当我需要抽象某一个经常会使用到的功能函数，但我不希望把每一个我需要用到的属性全部当作参数传入。然而我又希望这个函数可以用在更多的地方，有更好的可复用性，所以我可能会这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translateAFile</span>(<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    safeNoFile:<span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">default</span>:<span class="string">&#x27;English&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    defaultTarget:<span class="string">&#x27;Chinese&#x27;</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    path</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)</span></span><br></pre></td></tr></table></figure><p>但是这样依然非常的“不优雅”，我想到可能可以拆分成更小粒度的函数进行整合，我可能会：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do Sth.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestTranslate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do Sth.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// more function</span></span><br></pre></td></tr></table></figure><p>但是这样依然很麻烦，我不仅要记住所有的函数名，函数的参数和返回值，而中间任何一步的错误没有正确捕获，或美誉正确进行转换就会引发错误，大大增加了测试和开发的成本，反而不方便了。在这种情况下，“一直点下去”的方法显然就会优雅很多。但是……这其中是如何实现的呢？这可能要说到函数式编程。</p><h2 id="02-函数式编程的位置"><a href="#02-函数式编程的位置" class="headerlink" title="02 - 函数式编程的位置"></a>02 - 函数式编程的位置</h2><p>面对函数式编程，在考虑如何实现之前，可能要先研究一下函数式编程到底式什么层次的概念。函数式编程是一种编程范式，可以理解为与面向过程编程和面向对象编程同级。</p><p>如果说面向过程专注与逻辑的先后次序，逐步执行；面向对象编程专注与抽象对象和对象的属性和方法；函数式编程的关注点可能是“联系”，从这一点上，它就很“函数”，数学的那种“函数”。</p><h2 id="03-函数式编程依赖的特点和前提"><a href="#03-函数式编程依赖的特点和前提" class="headerlink" title="03 - 函数式编程依赖的特点和前提"></a>03 - 函数式编程依赖的特点和前提</h2><p>因为在JS中函数是<strong>一等公民</strong>，我们可以“随意”的使用函数，函数就是一个普通的对象（可以通过<code>new Function()</code>来创建）。函数可以赋值给变量，可以使用<code>new Function()</code>构造,甚至可以以作为另一个函数的返回值，而这是函数式编程的前提，是高阶函数，柯里化得以实现和应用的必须特性。</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>JS中，函数可以作为参数传递给另一函数，同时也可以作为一个函数的返回值。对于函数作为参数，我想每一个人都不陌生，每天都会使用。当我们需要为一个异步操作提供回调函数的时候，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params">foo,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// doSth</span></span><br><span class="line">    <span class="keyword">var</span> result = bar.doSth(foo)</span><br><span class="line">    callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，一个回调函作为函数的参数被传入，并且在函数中被调用。同时，函数也可作为一个函数的返回值，之前有提到过，函数可以赋值给变量。那么我们可以推断，当一个函数返回一个函数的时候，如果使用一个变量接收这个函数，我们就可以使用<strong>这个变量名+括号</strong>的形式来调用他，就像我们在把函数作为参数的情况一样。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">&#x27;Hello function&#x27;</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = makeFn()</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>我们可以看到，由于<strong>闭包</strong>的存在，声明的<code>msg</code>变量的作用域虽然局限在<code>makeFn</code>内部，但是我们在调用的时候，<code>msg</code>依然存在，没有被GC。在这里，它相当于<strong>被作为一种状态保存下来</strong>了。我们运行<code>Fn()</code>依然能顺利的在控制台打印<code>Hello function</code>。</p><p>这就隐隐的和之前的案例产生关联：“<strong>当我需要一些参数，但我不希望每次调用都传入，又想使耦合度降低，提高复用性</strong>”，高阶函数似乎提供了一种方案。他可以通过闭包返回一个包含一个我们需要的状态的函数，然后我们调用“生成的函数”就好了。这就是高阶函数的优点，概括起来说就是：</p><ol><li><p>抽象可以帮我们屏蔽细节，只需要关注与我们的目标</p></li><li><p>高阶函数是用来抽象通用的问题</p></li></ol><p>以上特点的存在，使得高阶函数成为我们函数式编程中一个不可或缺的部分。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>在讨论纯函数之前，我们先看几个案例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">numbers.slice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">numbers.slice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">numbers.slice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [4, 5]</span></span><br><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; []</span></span><br></pre></td></tr></table></figure><p>我们可以看到，对于<code>slice()</code>和<code>splice()</code>，在第一次执行的时候，都会返回数组的前三项。但是当继续执行的时候，<code>splice()</code>的执行结果就变的与预期不同了。假设我们抽象了这一逻辑，那么在多次，多处，或者链式调用的时候，情况就会变的复杂且难以控制。我们把这种情况叫做“函数具有<strong>副作用</strong>”。副作用的产生通常是函数内部改变了外部状态，或函数依赖于某一外部状态。这种“依赖”就会使得函数变的“<strong>不纯</strong>”。副作用的来源通常可能是：</p><ol><li><p>配置文件</p></li><li><p>数据库</p></li><li><p>用户输入</p></li><li><p>文件系统</p></li><li><p>……</p></li></ol><p>与此同时我们也可以得出纯函数的特点：</p><ol><li><p>无论多少次执行，相同的输入总会得到相同的输出</p></li><li><p>纯函数不会保留中间计算的结果，变量是不可变的</p></li></ol><p>因为纯函数的输入和输出我们都可以预期，所以我们很清楚函数的执行结果。这会给我们带来很多好处，比如：</p><ol><li><p><strong>可缓存</strong>——因为相同的输入总会得到相同的输出。所以如果对于一个耗时的操作，我们可以将结果缓存，并且重复执行的时候返回缓存的结果以节省时间和资源。</p></li><li><p><strong>易测试</strong>——因为纯函数的执行不依赖外部状态，只依赖明确的输入，所以可以不受限制的单独进行测试。</p></li><li><p><strong>并行安全</strong>——因为纯函数不需要访问共享的内存数据，也不会产生副作用，每一次执行都是相对独立的，所以在并行环境下可以十分看全的运行纯函数。</p></li></ol><p>那么如何把一个不纯的函数变成纯函数呢？有两种方法，增加参数和硬编码。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个不纯的函数</span></span><br><span class="line"><span class="keyword">let</span> mini = <span class="number">18</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age &gt;= mini</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAgeNew</span>(<span class="params">age, target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age &gt;= target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAgeHardcode</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mini = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> age &gt;= mini</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这两种方法都会带来另外的问题，第一种方法增加了参数，传递变的不方便。而且一但需要修改基准年龄，需要更改所有的调用，一但漏掉就会引发bug。第二种缺点变的更加的明显，众所周知在编程中我们要尽力的避免硬编码。以降低程序的耦合度。难道为了函数式编程我们就不得不向这些缺点妥协么？</p><h2 id="04-柯里化"><a href="#04-柯里化" class="headerlink" title="04 - 柯里化"></a>04 - 柯里化</h2><p>如果说让我用一句话来概括“柯里化”，就是利用闭包先预先“储存”一个参数，再通过高阶函数返回一个已经预先填好一个参数的新函数。简言之——<strong>柯里化过后的函数就是一个函数生成器</strong>。感觉还是有点绕，回到刚才的问题上。我们需要一个检查年龄是否合规的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> min = <span class="number">18</span></span><br><span class="line"><span class="keyword">return</span> age &gt;= min</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通纯函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span> (<span class="params">min, age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age &gt;= min</span><br><span class="line">&#125;</span><br><span class="line">checkAge(<span class="number">18</span>, <span class="number">24</span>)</span><br><span class="line">checkAge(<span class="number">18</span>, <span class="number">20</span>)</span><br><span class="line">checkAge(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span> (<span class="params">min</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age &gt;= min</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 写法</span></span><br><span class="line"><span class="keyword">let</span> checkAge = <span class="function"><span class="params">min</span> =&gt;</span> (<span class="function"><span class="params">age</span> =&gt;</span> age &gt;= min)</span><br><span class="line"><span class="keyword">let</span> checkAge18 = checkAge(<span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> checkAge20 = checkAge(<span class="number">20</span>)</span><br><span class="line">checkAge18(<span class="number">24</span>)</span><br><span class="line">checkAge18(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>通过上面的代码，我们可以进一步概括一个可能不那么准确但是非常好理解的概念——“<strong>柯里化就是利用闭包，返回一个已经动态的把其中一部分参数硬编码的函数</strong>”。这样一方面拥有硬编码只需要传递一部分参数的优点，一方面减小了调用的难度（如果需要修改只需要修改柯里化的部分就可以了）</p><h3 id="尝试实现柯里化"><a href="#尝试实现柯里化" class="headerlink" title="尝试实现柯里化"></a>尝试实现柯里化</h3><p>柯里化很方便，但是我们手动把每一个函数都柯里化会非常费神。那么我们如何编写一个函数，帮助我们把多个参数的纯函数柯里化呢？我们可以简单整理一下需求，比如先把这个函数命名为“<code>curry</code>”：</p><ol><li><p>curry函数需要把我们需要柯里化的函数作为输入</p></li><li><p>curry函数需要返回一个函数</p></li><li><p>柯里化过的函数，需要在没有提供足够多的参数的时候“暂存”已经输入的参数，并继续接收输入</p></li><li><p>当输入了完整的参数时，被柯里化的函数就会执行</p></li></ol><p>接下来我们来尝试实现一下这一函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curriedFn</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 判断实参和形参的个数</span></span><br><span class="line"><span class="keyword">if</span> (args.length &lt; func.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> curriedFn(...args.concat(<span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实参和形参个数相同，调用 func，返回结果</span></span><br><span class="line"><span class="keyword">return</span> func(...args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现这一需求，我们首先使用了剩余参数语法，即<code>...args</code>。这个语法允许我们将一个不定数量的参数表示为一个数组，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>同时我们使用了另一特性——一个函数的length属性为他的参数个数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum.length) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>解释了这些之后这一函数就很好理解了，接下来尝试一下它的应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b +c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curriedSum = curry(sum)</span><br><span class="line">curriedSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">2</span>) <span class="comment">// 5</span></span><br><span class="line">curriedSum(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">2</span>) <span class="comment">// 5</span></span><br><span class="line">curriedSum(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">2</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>不难看出，函数成功的被柯里化了，我们可以分多次，每次传入任意个数的参数即可。函数都将正常地被执行。</p><p>本篇主要讲述了函数式编程的思想，核心功能特点，以及柯里化。在下一篇中我们将进一步的讲述函数式编程以及柯里化的实际应用；以及进一步解决柯里化可能带来的问题。</p><blockquote><p><a href="https://t2.lagounews.com/fR8DRXRXcu024">https://t2.lagounews.com/fR8DRXRXcu024</a> 前端福音！这次彻底搞懂 Webpack 原理与实践，做合格前端“配置”工程师！点击链接7天搞定webpack原理和实践，仅需19元√强烈推荐！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE源码解读（1）</title>
      <link href="2020/12/06/vue-source-code-interpretation-1/"/>
      <url>2020/12/06/vue-source-code-interpretation-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vue源码解读学习笔记系列，逐步深入解读Vue设计和源码。</p><p>                                                            ——CafuChino</p></blockquote><h2 id="从虚拟DOM说起"><a href="#从虚拟DOM说起" class="headerlink" title="从虚拟DOM说起"></a>从虚拟DOM说起</h2><p>在使用Vue之前，Web项目最常用的库是Jquery。Jquery封装了各种常用的domApi，可以大大简化dom操作的难度，所以广受欢迎。但是无论是使用原生Js还是Jquery，当页面进行更新时依然要进行大量的DOM操作，如果要更改一个数据，可能需要逐层找到它的DOM元素，然后在对其进行更改。在开发大型项目时可能一次性要对大量DOM进行操作，这不仅会加大开发难度，还会加剧性能消耗。<strong>为什么？</strong></p><span id="more"></span><ol><li><p>DOM对象及其复杂，一个对象上有大量的属性和方法。在操作DOM对象的时候难免需要进行DOM对象和JS对象的相互转化，这一过程会造成很大的性能消耗。</p></li><li><p>DOM树发生变化或对CSS进行修改的时候，会造成重排（<code>relayout</code>）和重绘（<code>repaint</code>），这一过程会进一步加剧性能消耗。</p></li></ol><p>所以要优化页面性能，可以从两个方面入手：</p><ol><li><p>减少js对象和dom对象之间的转换次数</p></li><li><p>减少不必要的dom操作</p></li></ol><p>那么如果可以在一开始就维护和dom树相同的js对象结构，并且只更新需要更新的位置，便可以极大的优化性能。而用js对象来表示dom的形式就被称为虚拟dom。</p><h2 id="Snabbdom"><a href="#Snabbdom" class="headerlink" title="Snabbdom"></a>Snabbdom</h2><p>在使用Vue的时候，对于函数h()肯定不陌生。它在main.js中就曾出现过：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而其中的h函数就来源于Snabbdom这一虚拟dom库，其特点是简洁，模块化，高度可定制，号称是最快的Virtual Dom。Vue就是采用了修改过的Snabbdom作为虚拟dom核心。</p><h2 id="Snabbdom源码解析"><a href="#Snabbdom源码解析" class="headerlink" title="Snabbdom源码解析"></a>Snabbdom源码解析</h2><p>Snabbdom项目结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">├─package</span><br><span class="line">│  │  h.ts</span><br><span class="line">│  │  hooks.ts</span><br><span class="line">│  │  htmldomapi.ts</span><br><span class="line">│  │  init.ts</span><br><span class="line">│  │  is.ts</span><br><span class="line">│  │  jsx-global.ts</span><br><span class="line">│  │  jsx.ts</span><br><span class="line">│  │  thunk.ts</span><br><span class="line">│  │  tovnode.ts</span><br><span class="line">│  │  ts-transform-js-extension.cjs</span><br><span class="line">│  │  tsconfig.json</span><br><span class="line">│  │  vnode.ts</span><br><span class="line">│  │</span><br><span class="line">│  ├─helpers</span><br><span class="line">│  │      attachto.ts</span><br><span class="line">│  │</span><br><span class="line">│  └─modules</span><br><span class="line">│          attributes.ts</span><br><span class="line">│          class.ts</span><br><span class="line">│          dataset.ts</span><br><span class="line">│          eventlisteners.ts</span><br><span class="line">│          hero.ts</span><br><span class="line">│          module.ts</span><br><span class="line">│          props.ts</span><br><span class="line">│          style.ts</span><br><span class="line">│</span><br><span class="line">└─test</span><br><span class="line">    │  tsconfig.json</span><br><span class="line">    │  </span><br><span class="line">    ├─benchmark</span><br><span class="line">    │      core.ts</span><br><span class="line">    │</span><br><span class="line">    └─unit</span><br><span class="line">            attachto.ts</span><br><span class="line">            attributes.ts</span><br><span class="line">            core.ts</span><br><span class="line">            dataset.ts</span><br><span class="line">            eventlisteners.ts</span><br><span class="line">            htmldomapi.ts</span><br><span class="line">            jsx.tsx</span><br><span class="line">            style.ts</span><br><span class="line">            thunk.ts</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 手撸源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用程序猿的方法打造万无一失的存稿网站(1)</title>
      <link href="2020/07/17/how-to-build-a-foolproof-site-for-manuscripts-using-the-method-of-programmers-1/"/>
      <url>2020/07/17/how-to-build-a-foolproof-site-for-manuscripts-using-the-method-of-programmers-1/</url>
      
        <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>采用本方案，你需要：</p><ol><li><p>基础的英语水平</p></li><li><p>一台电脑</p></li><li><p>一个邮箱</p></li><li><p>一个清醒的，可以在面对黑框命令行时冷静的头脑</p></li></ol><p>你需要以下软件：</p><ol><li><p>Git</p></li><li><p>Marktext</p></li><li><p>Node</p></li></ol><span id="more"></span><p>不过你<strong>无需</strong>为这些软件操心，我会把这些软件打包好提供给你。</p><p>如果你拥有一张visa信用卡，或者肯为你的这个网站花点钱，你也可以以大约$5/月的价格购买一台服务器，这将成倍的降低难度。但是本篇教程无需<strong>任何</strong>花费</p><hr><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>安装我提供的压缩包内的三个文件，你可以按照他们后面的标号顺序安装，也可以随便什么顺序。如果不出意外，应该全部确定确定确定过去就可以了。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>按下键盘的<code>win+R</code>，win键可能是一个windows小徽标，也可能写着win。在弹出的窗口中输入cmd，按下回车，应该会出现一个黑框命令行了。</p><p>以下几条命令可以测试你有没有正确安装以上软件，如果一切正常，命令的结果应该会和我的很相似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">v12.18.2 </span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(很长的一段帮助信息)</span><br></pre></td></tr></table></figure><p>如果一切正常的话，就可以继续了。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先，注册一个Github账号——这个是常规操作不多介绍了。</p><p>注册完成之后，点击首页上左侧栏用户名下面的绿色New按钮，新建一个仓库:</p><img src="https://chinocdn.cafuchino.cn/pic/20200717020710.png" title="" alt="" data-align="center"><p>然后在<code>Repository name</code>处填入<code>用户名.github.io</code>，我的用户名是CafuChino，所以我填入<code>CafuChino.github.io</code>，效果如图所示：</p><img src="https://chinocdn.cafuchino.cn/pic/20200717020768.png" title="" alt="" data-align="left"><p>点击Create repository，完成创建这个代码仓库。创建成功之后，我们点击<code>creating a new file</code>来随便写点什么来测试：</p><img src="https://chinocdn.cafuchino.cn/pic/20200717020773.png" title="" alt="" data-align="center"><p>之后我们在文件名处填写<code>index.html</code>（必须是这个），在内容里写下“Hello World！”：</p><img src="https://chinocdn.cafuchino.cn/pic/20200717020784.png" title="" alt="" data-align="center"><p>点击页面底部的绿色<code>Commit new file</code>按钮，保存这个文件。这时，回到了仓库的页面，点击右上角的settings选项：</p><img src="https://chinocdn.cafuchino.cn/pic/20200717020737.png" title="" alt="" data-align="center"><p>向下滚动至GitHub Pages，你会看到你的网站已经成功部署的好消息：</p><p><img src="https://chinocdn.cafuchino.cn/pic/20200717020707.png"></p><p>我的网站地址就是<a href="https://cafuchino.github.io/">https://cafuchino.github.io</a> 了，你的应该和我类似，也是包含了你的用户名。现在让我们打开网站看看效果，点击蓝色链接，“Hello World!”已经写在了网页上：</p><p><img src="https://chinocdn.cafuchino.cn/pic/20200717020711.png"></p><p>其实到了这一步，你的网站已经搭建完成，github免费提供一个月100G的网络流量，每个小时最多10次的页面改动，对于存稿来说已经十分足够。如果你想添加一篇新的文章，可以重复之前的添加文件操作，新建一个html类型的文件，将你的文章复制进去，然后把外链发到你希望发送的平台，比如：</p><p><img src="https://chinocdn.cafuchino.cn/pic/20200717020753.png"></p><p>点击页面下方的绿色<code>Commit new file</code>按钮，就像之前一样，然后成功之后在刚才的地址后面加上你的html文件名：</p><p><img src="https://chinocdn.cafuchino.cn/pic/20200717020705.png"></p><p>至此，你已经学会了如何用程序猿的方法存稿，可能你会发现之前的软件一个也没用上，而且这个网站也太丑了!而之前的那些软件可以帮助你生成更好看的网页，而不用成为一个真正的 程序猿。其余的教程我将在下一篇教程中讲解。</p><p>如果你觉得这个难度可以接受，想要拥有更加绚丽的个人网页，或者拥有一个万无一失的存稿基地，欢迎在我的这篇文章下留言让我知道，我会同步更新接下来的教程内容。</p><p>愿所有写手都能自由创作！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 做个程序猿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue监听子组件的声明周期？</title>
      <link href="2020/07/07/does-vue-monitor-the-life-cycle-of-child-components/"/>
      <url>2020/07/07/does-vue-monitor-the-life-cycle-of-child-components/</url>
      
        <content type="html"><![CDATA[<h2 id="2020-07-03-每日一题：Vue监听子组件的声明周期？"><a href="#2020-07-03-每日一题：Vue监听子组件的声明周期？" class="headerlink" title="2020-07-03 每日一题：Vue监听子组件的声明周期？"></a>2020-07-03 每日一题：Vue监听子组件的声明周期？</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue父组件可以监听到子组件的生命周期吗？如果可以的话写出实现方法。</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>由于技术是在是太烂，以往写 vue项目的时候很少有自行抽象组件的时候，都是用现成的组件库，所以父子组件通讯一直到现在都不熟。正好借这个机会整理一下。</p><h3 id="关键的-emit"><a href="#关键的-emit" class="headerlink" title="关键的$emit"></a>关键的$emit</h3><p>(成为一个无情的看文档机器)</p><p>仔细过了一遍文档，一句话总结<code>$emit</code>就是触发这个实例上的一个指定的事件。“事件”的范围就很宽泛了，比如<code>@click</code>点击就是一个事件。<code>$emit</code>允许我们自定义一个事件，在父组件中使用这个组件时监听，同时在子组件中自行触发，实现了子组件向父组件的通讯。</p><p>Talk is cheep.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line"></span><br><span class="line">&lt;childComponent @mounted=<span class="string">&quot;doSomeThing&quot;</span>&gt;...&lt;/childComponent&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.$emit(<span class="string">&quot;mounted&quot;</span>,&#123;<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用钩子"><a href="#使用钩子" class="headerlink" title="使用钩子"></a>使用钩子</h3><p>坦白讲我也没看到hook相关的文档在哪里，好在代码很简单，直接上文档。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line">&lt;childComponent @hook:mounted=<span class="string">&quot;handleChildMounted&quot;</span>&gt;...&lt;/childComponent&gt;</span><br></pre></td></tr></table></figure><p>其他声明周期也可以使用hook进行监听。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>null=?</title>
      <link href="2020/06/18/null/"/>
      <url>2020/06/18/null/</url>
      
        <content type="html"><![CDATA[<h2 id="2020-06-18-每日一题：null-？"><a href="#2020-06-18-每日一题：null-？" class="headerlink" title="2020-06-18 每日一题：null=？"></a>2020-06-18 每日一题：null=？</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写出答案并解释原因</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> &lt; <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> &lt;= <span class="number">0</span>);</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>有关于几个特殊值<code>undefinded,null,NaN</code>还有0和空字符空数组等等是经常会拿出来出题的考点……</p><h3 id="null到底代表了什么？"><a href="#null到底代表了什么？" class="headerlink" title="null到底代表了什么？"></a>null到底代表了什么？</h3><blockquote><p>值 <code>null</code> 特指对象的值未设置。它是 JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">基本类型</a> 之一，在布尔运算中被认为是<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">falsy</a>。值 <code>null</code> 是一个字面量，不像 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>，它不是全局对象的一个属性。<code>null</code> 是表示缺少的标识，指示变量未指向任何对象。把 <code>null</code> 作为尚未创建的对象，也许更好理解。在 API 中，<code>null</code> 常在返回类型应是一个对象，但没有关联的值的地方使用。</p></blockquote><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol><li><p><code>null</code>只等于<code>undefined</code>，他不等于0，也不是0。</p></li><li><p>关系运算符中，会先尝试将运算元转Number，而<code>==</code>不会。</p></li></ol><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p><code>false,false,true</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode题解-1014</title>
      <link href="2020/06/17/leetcode-problem-solution1014/"/>
      <url>2020/06/17/leetcode-problem-solution1014/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode每日一题-1014-最佳观光组合"><a href="#LeetCode每日一题-1014-最佳观光组合" class="headerlink" title="LeetCode每日一题 1014- 最佳观光组合"></a>LeetCode每日一题 1014- <a href="https://leetcode-cn.com/problems/best-sightseeing-pair/">最佳观光组合</a></h2><p>给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。</p><p>一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。</p><p>返回一对观光景点能取得的最高分。</p><p>示例：</p><blockquote><p><strong>输入：</strong>[8,1,5,2,6]<br><strong>输出：</strong> 11<br><strong>解释：</strong> i = 0, j = 2, <code>A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</code></p></blockquote><span id="more"></span><p>看到就很没出息的开始暴力枚举了，双重循环完整遍历，时间复杂度O(n^2)，不出意外的贴边过，差点就没通过时间限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxScoreSightseeingPair = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;A.length;j++)&#123;</span><br><span class="line">            <span class="keyword">const</span> score = A[i]+A[j]+i-j;</span><br><span class="line">            <span class="keyword">if</span> (score&gt;ans)&#123;</span><br><span class="line">                ans = score</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是仔细想想这很像双指针问题，慢指针是步进的，另一个指针似乎做了很多重复的循环，可以从这里优化。原方程为<code>A[i] + A[j] + i - j</code>，变形一下可得<code>(A[i]+i)+(A[j]-j)</code>。问题迎刃而解，对于每一项来说，他的<code>A[i]+i</code>和<code>A[j]-j</code>都是固定的，所以我们只需要一次完整的遍历。在计算<code>A[j]-j</code>的时候，可以将<code>A[i]+i</code>和之前的最大值进行比较，最后相加即可。总时间复杂度为O(n):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">A</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxScoreSightseeingPair = <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span>; max1 = A[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>;j&lt;A.length;j++)&#123;</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, max1 + A[j] - j)</span><br><span class="line">        max1 = <span class="built_in">Math</span>.max(max1,A[j] + j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖/节流函数原理和实现</title>
      <link href="2020/06/17/principle-and-realization-of-antishakethrottle-function/"/>
      <url>2020/06/17/principle-and-realization-of-antishakethrottle-function/</url>
      
        <content type="html"><![CDATA[<h2 id="2020-06-17-每日一题：防抖和节流函数"><a href="#2020-06-17-每日一题：防抖和节流函数" class="headerlink" title="2020-06-17 每日一题：防抖和节流函数"></a>2020-06-17 每日一题：防抖和节流函数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounse = <span class="function">(<span class="params">fn,delay</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 介绍防抖函数原理，并实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn,delay=<span class="number">500</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 介绍节流函数原理，并实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>第一次接触防抖和节流函数是在大一完成web学习的第一个项目时，当时需要对鼠标滚轮进行监听，但是滚轮一次会触发很多很多次事件。由此接触到了防抖和节流函数。所以如果用一句话概括一下防抖和节流函数，我的表达就是：防止一个函数被连续快速多次触发，消耗太多资源或者造成预期外的效果。</p><h3 id="防抖函数or节流函数？"><a href="#防抖函数or节流函数？" class="headerlink" title="防抖函数or节流函数？"></a>防抖函数or节流函数？</h3><p>防抖函数和节流函数都可以防止操作被连续触发，那么他们的区别是什么呢？</p><blockquote><p><strong>防抖函数</strong>：在事件触发n秒后再执行回调，如果这期间再次触发，则<strong>重新计时</strong></p><p><strong>节流函数</strong>：在一定时间内，只能触发一次函数</p></blockquote><p>倘若一个按钮绑定了某一事件，而这个按钮被连续不断的快速点击，防抖函数会等到停止点击n秒后才触发，而防抖函数每隔一段时间就会被触发一次。</p><p>所以由此可知，防抖函数和节流函数的使用场景分别为：</p><blockquote><p><strong>防抖函数</strong>：需要保证提交信息为最新的时候，比如登录，滑块等。</p><p><strong>节流函数</strong>：需要一个较缓的频率提交一直变化的值时，如搜索推荐项。</p></blockquote><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounse = <span class="function">(<span class="params">fn,delay</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//清除定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>.args);</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn,delay=<span class="number">500</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 开始计时</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.applay(<span class="built_in">this</span>,args);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;,delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随页面滚动淡入的动效？</title>
      <link href="2020/06/17/the-dynamic-effect-of-fading-in-as-page-scrolls/"/>
      <url>2020/06/17/the-dynamic-effect-of-fading-in-as-page-scrolls/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这种前端动效交互感很强啊，以前使用原生的鼠标滚轮监听写过类似的功能。还要加防抖函数，麻烦的很。这段时间参考了套用的一个网页模板，找到了最简单实现这个功能的办法。</p><p>————CafuChino</p></blockquote><p>需要用到的库：</p><ul><li>Animate.css：<a href="https://daneden.github.io/animate.css/">https://daneden.github.io/animate.css/</a>(提供写好的动效)</li><li>waypoint：<a href="https://github.com/imakewebthings/waypoints">https://github.com/imakewebthings/waypoints</a>(设置监听点)</li></ul><p>在之前这样的应用中，因为不知道如何追踪页面滚动进度，所以设计成了像幻灯片切换的效果，使用的方法是原生监听鼠标滚轮，添加节流函数操作改变一个计数变量，这个计数变量的值为当前页。至于动效的实现是在翻页的同时加上一个绑定动画的类，一段时间之后再删除这个类。总而言之非常繁琐，一个简单的页面写了百余行的js专门用来操作动效。现在找到了比较简单的办法，不过思路在一些方面上依然一样。</p><span id="more"></span><h2 id="waypoint库："><a href="#waypoint库：" class="headerlink" title="waypoint库："></a>waypoint库：</h2><p>waypoint库是一个可以监听页面滚动位置的库，他监听的方式是监听某一个元素与屏幕定的距离。当设定元素与屏幕距离小于等于所设定的百分比，就会触发事件。而且还可以设定触发时的页面滚动方向，这就形成了向下滚动界面，屏幕上的元素淡入（可以使任何动效或者是任何事件）。插件的使用很简单，文档已经很完整了，所以我只记录一下我摸索的方案：</p><p>把包裹需要绑定动效的父容器设定class 为<code>animate-box</code> ,需要绑定动效的元素设定class为<code>to-animate</code>，开始动效添加class为<code>animated</code>，这样不仅比较容易判定元素的状态，而且可以允许父元素内有绑定动效的元素，也有不绑定的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;css部分</span><br><span class="line">.animated &#123;</span><br><span class="line">-webkit-animation-duration: 1s;</span><br><span class="line">animation-duration: 1s;</span><br><span class="line">-webkit-animation-fill-mode: both;</span><br><span class="line">animation-fill-mode: both;</span><br><span class="line">&#125;&#x2F;&#x2F;animate.css中有定义，可以写在页面css中方便修改</span><br><span class="line">.to-animate &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，未执行动效的元素依然存在，只是被调整成了完全透明。如果将其设为hidden，将会导致布局闪烁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;js部分,使用了jq</span><br><span class="line">$(&#39;.animate-box&#39;).waypoint(function (direction) &#123;</span><br><span class="line">if (direction &#x3D;&#x3D;&#x3D; &#39;down&#39; &amp;&amp; !$(this).hasClass(&#39;animated&#39;)) &#123;</span><br><span class="line">$(this.element).children(&#39;.to-animate&#39;).addClass(&#39;fadeInUp animated&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">offset: &#39;75%&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>offset指的是当元素与顶部距离的触发值，direction代表的是达到触发值的时候的方向。有一点非常重要：</p><p><strong>这里的this指代的是监听点本身，如果直接使用this，将会获取不到其子元素，而this.element表示的才是绑定监听的元素，一定注意！</strong></p><p>之后页面上的元素就会在第一次滚动到那里的时候渐隐显示了，animate.css中定义了很多种的动效类型（代码里的<code>fadeInUp</code>就是其中定义的），想要使用哪种动效，直接添加指定的类就可以了，非常方便√当然waypoint也可以不止绑定动效，可以绑定请求，达到用户统计的作用等等；通过对用户浏览情况统计分析用户意向等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43 道检验基础的 JavaScript 面试题（1）</title>
      <link href="2019/09/09/43-basic-javascript-interview-questions-1/"/>
      <url>2019/09/09/43-basic-javascript-interview-questions-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目来源于 <a href="https://zhuanlan.zhihu.com/p/75359676">https://zhuanlan.zhihu.com/p/75359676</a> ，觉得不错。一边做一边记录。</p><p>————CafuChino</p></blockquote><span id="more"></span><h2 id="1-下面代码的输出是什么？"><a href="#1-下面代码的输出是什么？" class="headerlink" title="1. 下面代码的输出是什么？"></a><strong>1. 下面代码的输出是什么？</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的考点无非就是考察let的特性和var的变量提升，因为众所周知var存在变量提升。考虑不周的话可能会认为第一行会输出“Lydia”，我第一反应的时候就犯了这个错误。实则不然，即使存在变量提升，调用的时候依然没有为name赋值，所以应该返回 <code>undefined</code>，而age因为let声明导致死区，变量不提升，会报错 <code>ReferenceError</code>。</p><h2 id="2-下面代码的输出是什么"><a href="#2-下面代码的输出是什么" class="headerlink" title="2. 下面代码的输出是什么?"></a><strong>2. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的考点是ES6中let的块级作用域和js的事件执行机制。答案是333和012</p><p>由于<code>JavaScript</code>中的事件执行机制，<code>setTimeout</code>函数真正被执行时，循环已经走完。 由于第一个循环中的变量<code>i</code>是使用<code>var</code>关键字声明的，因此该值是全局的。 在循环期间，我们每次使用一元运算符<code>++</code>都会将<code>i</code>的值增加<code>1</code>。 因此在第一个例子中，当调用<code>setTimeout</code>函数时，<code>i</code>已经被赋值为<code>3</code>。</p><p>在第二个循环中，使用<code>let</code>关键字声明变量<code>i</code>：使用<code>let</code>（和<code>const</code>）关键字声明的变量是具有块作用域的（块是<code>&#123;&#125;</code>之间的任何东西）。 在每次迭代期间，<code>i</code>将被创建为一个新值，并且每个值都会存在于循环内的块级作用域。</p><h2 id="3-下面代码的输出是什么"><a href="#3-下面代码的输出是什么" class="headerlink" title="3. 下面代码的输出是什么?"></a><strong>3. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shape = &#123;</span><br><span class="line">radius: <span class="number">10</span>,</span><br><span class="line"><span class="function"><span class="title">diameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.radius * <span class="number">2</span>;</span><br><span class="line">&#125;,</span><br><span class="line">perimeter: <span class="function">() =&gt;</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shape.diameter();</span><br><span class="line">shape.perimeter();</span><br></pre></td></tr></table></figure><p>这道题的考点是箭头函数的this指代问题。与普通函数不同，箭头函数的this指代 它所在上下文（定义时的位置）的环境 。也就是说实际使用的时候，perimeter中的this指的不是shape，而是window（全局定义的变量和函数归属于window），所以会返回undefined。这里答案是20和NaN（NOT a NUMBER）</p><h2 id="4-下面代码的输出是什么"><a href="#4-下面代码的输出是什么" class="headerlink" title="4. 下面代码的输出是什么?"></a><strong>4. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="literal">true</span>;</span><br><span class="line">!<span class="string">&quot;Lydia&quot;</span>;</span><br></pre></td></tr></table></figure><p>答案是1和false，涉及到两个特性：</p><ul><li>一元加号会把<code>Boolean</code>转换成数字，true为1，false为0。</li><li>字符串是真值，！为非，非真为false。</li></ul><h2 id="5-哪个选项是不正确的"><a href="#5-哪个选项是不正确的" class="headerlink" title="5. 哪个选项是不正确的?"></a><strong>5. 哪个选项是不正确的?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bird = &#123;</span><br><span class="line">size: <span class="string">&quot;small&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouse = &#123;</span><br><span class="line">name: <span class="string">&quot;Mickey&quot;</span>,</span><br><span class="line">small: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>A:<code>mouse.bird.size</code></li><li>B:<code>mouse[bird.size]</code></li><li>C:<code>mouse[bird[&quot;size&quot;]]</code></li><li>D: All of them are valid</li></ul><p>选A（仔细分析过后居然选对了），开发经验！</p><p>这道题其实考察的是JavaScript的对象键值，对象键值本质上依然是字符串，方括号里的值会被有限计算。了解这个规律之后其实很好解。A选项mouse对象没有bird键值，会返回undefined，undefined.size自然会报错 <code>Cannot read property &quot;size&quot; of undefined </code>剩下两个方括号里的值都可以计算出mouse对象有的键值。</p><h2 id="6-下面代码的输出是什么"><a href="#6-下面代码的输出是什么" class="headerlink" title="6. 下面代码的输出是什么?"></a><strong>6. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">greeting</span>: <span class="string">&quot;Hey!&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line"></span><br><span class="line">d = c;</span><br><span class="line">c.greeting = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(d.greeting);</span><br></pre></td></tr></table></figure><p>答案是”Hello”，这道题真的是个大坑，不过有开发经验的话应该会有所体会。如果单纯按照赋值思想考虑的很容易得出，d被赋值的时候依然是<code>&#123; greeting: &quot;Hey!&quot; &#125;</code>。所以答案是”Hey”（这是错误的！）原文作者已经写得很好了，所以直接贴上引用：</p><blockquote><p>在<code>JavaScript</code>中，当设置它们彼此相等时，所有对象都通过引用进行交互。首先，变量<code>c</code>为对象保存一个值。 之后，我们将<code>d</code>指定为<code>c</code>与对象相同的引用。** 更改一个对象时，可以更改所有对象。 **</p><p>————引自原文</p></blockquote><h2 id="7-下面代码的输出是什么"><a href="#7-下面代码的输出是什么" class="headerlink" title="7. 下面代码的输出是什么?"></a><strong>7. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == b);</span><br><span class="line"><span class="built_in">console</span>.log(a === b);</span><br><span class="line"><span class="built_in">console</span>.log(b === c);</span><br></pre></td></tr></table></figure><p>答案是true，false，false，难度不大，就是<code>==</code>只比较值，<code>===</code>不仅比较值还比较类型，对象和整数肯定不会相等。</p><h2 id="8-下面代码的输出是什么"><a href="#8-下面代码的输出是什么" class="headerlink" title="8. 下面代码的输出是什么?"></a><strong>8. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">colorChange</span>(<span class="params">newColor</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.newColor = newColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">&#123; newColor = <span class="string">&quot;green&quot;</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.newColor = newColor;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddie = <span class="keyword">new</span> Chameleon(&#123; <span class="attr">newColor</span>: <span class="string">&quot;purple&quot;</span> &#125;);</span><br><span class="line">freddie.colorChange(<span class="string">&quot;orange&quot;</span>);</span><br></pre></td></tr></table></figure><p>此题考点为static，static声明的方法为静态方法，只在构造函数中存在，在子对象中不存在。freddie对象中实际没有<code>colorChange</code>方法，会报错<code>TypeError</code>。</p><h2 id="9-下面代码的输出是什么"><a href="#9-下面代码的输出是什么" class="headerlink" title="9. 下面代码的输出是什么?"></a><strong>9. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting;</span><br><span class="line">greetign = &#123;&#125;; <span class="comment">// Typo!</span></span><br><span class="line"><span class="built_in">console</span>.log(greetign);</span><br></pre></td></tr></table></figure><p>（送分题？）变量不经声明直接使用归属于global或者window，为全局变量。这个打错了的案例只是声明了个空对象而已。输出也是空对象<code>&#123;&#125;</code>。</p><h2 id="10-当我们这样做时会发生什么"><a href="#10-当我们这样做时会发生什么" class="headerlink" title="10. 当我们这样做时会发生什么?"></a><strong>10. 当我们这样做时会发生什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bark</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bark.animal = <span class="string">&quot;dog&quot;</span>;</span><br></pre></td></tr></table></figure><p>这道题很有趣，正解是没什么问题，正常执行。因为js中的函数也是一种特殊的对象，加一个属性也没什么问题。而我的思路比较特殊，考虑到如果没有赋值单独读取的话应该会返回<code>undefined</code>，对<code>undefined</code>进行赋值应该不会出问题。不过还是领会函数的正确本质比较重要。</p><h2 id="11-下面代码的输出是什么"><a href="#11-下面代码的输出是什么" class="headerlink" title="11. 下面代码的输出是什么?"></a><strong>11. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.firstName = firstName;</span><br><span class="line"><span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line">Person.getFullName = <span class="function">() =&gt;</span> <span class="built_in">this</span>.firstName + <span class="built_in">this</span>.lastName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member.getFullName());</span><br></pre></td></tr></table></figure><p>这道题没做出来，以为还是箭头函数this指代的问题。但实际上答案应该是 TypeError 。原因引用原作者：</p><blockquote><p>您不能像使用常规对象那样向构造函数添加属性。 如果要一次向所有对象添加功能，则必须使用原型。 所以在这种情况下应该这样写：<code>Person.prototype.getFullName = function () &#123;   return </code>${this.firstName} ${this.lastName}<code>; &#125; </code>这样会使<code>member.getFullName()</code>是可用的，为什么样做是对的？ 假设我们将此方法添加到构造函数本身。 也许不是每个<code>Person</code>实例都需要这种方法。这会浪费大量内存空间，因为它们仍然具有该属性，这占用了每个实例的内存空间。 相反，如果我们只将它添加到原型中，我们只需将它放在内存中的一个位置，但它们都可以访问它！</p><p>————引自原文</p></blockquote><p>P.S.： javascript中的每个对象都有prototype属性，Javascript中对象的prototype属性的解释是：返回对象类型原型的引用。 也就是说通过protocol属性，我们可以对函数原型的属性和方法进行操作。这道题和上一题的区别是：上一道题是常规对象（一个普通的函数），而这个是个构造函数。</p><h2 id="12-下面代码的输出是什么"><a href="#12-下面代码的输出是什么" class="headerlink" title="12. 下面代码的输出是什么?"></a><strong>12. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.firstName = firstName;</span><br><span class="line"><span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lydia = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> sarah = Person(<span class="string">&quot;Sarah&quot;</span>, <span class="string">&quot;Smith&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lydia);</span><br><span class="line"><span class="built_in">console</span>.log(sarah);</span><br></pre></td></tr></table></figure><p>答案是 <code>Person &#123;firstName: &quot;Lydia&quot;, lastName: &quot;Hallie&quot;&#125;</code> ， <code>undefined</code> 。</p><p>第一个可以正常输出没有任何疑问，第二个的声明问题在于没有用<code>new</code>，（this真的是高频考点啊）如果没有用new，这个对象就归属于全局，此时的this是global或者window，sarah根本没有被赋值，自然是undefined。</p><h2 id="12-事件传播的三个阶段是什么？"><a href="#12-事件传播的三个阶段是什么？" class="headerlink" title="12. 事件传播的三个阶段是什么？?"></a><strong>12. 事件传播的三个阶段是什么？?</strong></h2><p>答案： 在捕获阶段，事件通过父元素向下传递到目标元素。 然后它到达目标元素，冒泡开始。 </p><p>案例：假设一个弹出登录窗口的页面，父元素为一个半透明遮罩，绑定点击事件为隐藏自身。子元素为登录窗口本身，上面有提交按钮。实际上当提交按钮被点击的时候，提交后父元素点击事件也被触发，这个过程叫做冒泡。 <strong>事件的对象有一个stopPropagation()方法可以阻止事件冒泡</strong> 。事件捕获是指不太具体的节点应该更早的接收到事件，而最具体的节点应该最后接收到事件 ， <strong>stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。</strong> 有点迷惑的话，有一张图解：</p><p><img src="http://chinocdn.cafuchino.cn/pic/201909092047432.png" alt="pic/201909092047432.png"></p><p>感觉比较有趣，有空单开一篇文章分析其机制好了。</p><h2 id="13-所有对象都有原型？"><a href="#13-所有对象都有原型？" class="headerlink" title="13. 所有对象都有原型？"></a><strong>13. 所有对象都有原型</strong>？</h2><p>答： 除<strong>基础对象</strong>外，所有对象都有原型。  基础对象的原型是<code>null</code>。 </p><h2 id="14-下面代码的输出是什么"><a href="#14-下面代码的输出是什么" class="headerlink" title="14. 下面代码的输出是什么?"></a><strong>14. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>答案为”12”，因为在这里发生了 隐式类型转换，1被隐式转换成了字符串。js中加号可以用来连接字符串，所以输出了”12”</p><h2 id="15-下面代码的输出是什么"><a href="#15-下面代码的输出是什么" class="headerlink" title="15. 下面代码的输出是什么?"></a><strong>15. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number++);</span><br><span class="line"><span class="built_in">console</span>.log(++number);</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br></pre></td></tr></table></figure><p>答案为：0,2,2，这道题感觉是C语言考试的相似题啊，自增放在前面是先自增再返回，放在后面是先返回再自增。所以过程是“返回=&gt;自增=&gt;自增=&gt;返回=&gt;返回”</p><h2 id="16-下面代码的输出是什么"><a href="#16-下面代码的输出是什么" class="headerlink" title="16. 下面代码的输出是什么?"></a><strong>16. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonInfo</span>(<span class="params">one, two, three</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(one);</span><br><span class="line"><span class="built_in">console</span>.log(two);</span><br><span class="line"><span class="built_in">console</span>.log(three);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">getPersonInfo<span class="string">`<span class="subst">$&#123;person&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure><p>答案： <code>[&quot;&quot;, &quot;is&quot;, &quot;years old&quot;] Lydia 21</code>  因为如果使用标记的模板字符串，则第一个参数的值始终是字符串值的数组。 其余参数获取传递到模板字符串中的表达式的值。（这样做的目的是什么？？？）</p><h2 id="17-下面代码的输出是什么"><a href="#17-下面代码的输出是什么" class="headerlink" title="17. 下面代码的输出是什么?"></a><strong>17. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data === &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;You are an adult!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;You are still an adult.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hmm.. You don&#x27;t have an age I guess`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAge(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br></pre></td></tr></table></figure><p>这道题很有趣，因为对于对象来说，比较的不是他们的值，而是引用的地址hhhh，所以无论是相等还是严格相等都会判断false。（天坑啊）答案为：<code>Hmm.. You don&#39;t have an age I guess</code>，如果想比较值的话大概只能把值读取出来进行比较了。</p><h2 id="18-下面代码的输出是什么"><a href="#18-下面代码的输出是什么" class="headerlink" title="18. 下面代码的输出是什么?"></a><strong>18. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>);</span><br></pre></td></tr></table></figure><p>答案为： <code>&quot;object&quot;</code>，扩展运算符（<code>... args</code>）返回一个带参数的数组。 数组是一个对象，因此<code>typeof args</code>返回<code>object</code>。 </p><p>P.S.：** <strong>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前</strong>对象**之中 （是对象啊！）</p><h2 id="20-下面代码的输出是什么"><a href="#20-下面代码的输出是什么" class="headerlink" title="20. 下面代码的输出是什么?"></a><strong>20. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge();</span><br></pre></td></tr></table></figure><p>答案为： <code>ReferenceError</code>，是<code>&quot;use strict&quot;;</code>的锅，严格模式下不可以不经声明就使用变量，age属性不会自动变成全局变量的。</p><h2 id="21-下面代码的输出是什么"><a href="#21-下面代码的输出是什么" class="headerlink" title="21. 下面代码的输出是什么?"></a><strong>21. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">eval</span>(<span class="string">&quot;10*10+5&quot;</span>);</span><br></pre></td></tr></table></figure><p>答案为：105——即使是是字符串eval也会对表达式进行求值的。（当然需要是个表达式）</p><h2 id="22-cool-secret可以访问多长时间"><a href="#22-cool-secret可以访问多长时间" class="headerlink" title="22. cool_secret可以访问多长时间?"></a><strong>22. cool_secret可以访问多长时间?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">&quot;cool_secret&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>其实就是在问sessionStorage的存储时间，事实上，sessionStorage中的数据关闭选项卡就没有了， localStorage 中的数据将会永远存在。（TODO：写篇这个的笔记吧。）</p><h2 id="23-下面代码的输出是什么"><a href="#23-下面代码的输出是什么" class="headerlink" title="23. 下面代码的输出是什么?"></a><strong>23. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><p>答案：10，var重复声明变量会直接覆盖。</p><h3 id="24-下面代码的输出是什么"><a href="#24-下面代码的输出是什么" class="headerlink" title="24. 下面代码的输出是什么?"></a><strong>24. 下面代码的输出是什么?</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">1</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">3</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">obj.hasOwnProperty(<span class="number">1</span>);</span><br><span class="line">set.has(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">set.has(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>答案：true，true，false，true，对象的键值不指定字符串也是字符串，所以可以都返回true，而set不行。</p><h2 id="25-下面代码的输出是什么"><a href="#25-下面代码的输出是什么" class="headerlink" title="25. 下面代码的输出是什么?"></a><strong>25. 下面代码的输出是什么?</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;one&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;two&quot;</span>, <span class="attr">a</span>: <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>答案： <code>&#123; a: &quot;three&quot;, b: &quot;two&quot; &#125;</code> 对象中相同的键的值会被替换，但是会保留第一次出现的位置。（想的简单点不就好了吗…. ：-））</p><p>（——未完待续）</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos+selenium的那些坑</title>
      <link href="2019/09/04//"/>
      <url>2019/09/04//</url>
      
        <content type="html"><![CDATA[<p>在开发的时候遇到了大坑，本文章转自 ：<a href="https://blog.csdn.net/wkb342814892/article/details/81591394">https://blog.csdn.net/wkb342814892/article/details/81591394</a> 对我有效，留档备用。</p><span id="more"></span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">CentOS + Selenium 用法小结</span><br><span class="line">使用场景</span><br><span class="line">在CentOS下使用Selenium，这里的CentOS是指无GUI的Server版，其特殊性在于，没有可以供输出的显示界面，除了常见的headless方法以外，还有xvfb等工具可以使用，本文即记录我使用时碰到的一些流程及坑点。</span><br><span class="line">解决方案</span><br><span class="line">headless方法的使用</span><br><span class="line">以Chrome为例</span><br><span class="line">安装selenium</span><br><span class="line">pip install selenium</span><br><span class="line">安装chrome-browser</span><br><span class="line">wget https:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;direct&#x2F;google-chrome-stable_current_x86_64.rpm --no-check-certificate</span><br><span class="line">sudo yum install google-chrome-stable_current_x86_64.rpm</span><br><span class="line">安装chromedriver：一个用来和chrome交互的接口</span><br><span class="line">sudo yum install chromedriver</span><br><span class="line">编写test.py文件</span><br><span class="line">test.py</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">chrome_options &#x3D; Options()</span><br><span class="line">chrome_options.add_argument(&#39;--headless&#39;) # 16年之后，chrome给出的解决办法，抢了PhantomJS饭碗</span><br><span class="line">chrome_options.add_argument(&#39;--disable-gpu&#39;)</span><br><span class="line">chrome_options.add_argument(&#39;--no-sandbox&#39;)  # root用户不加这条会无法运行</span><br><span class="line">driver &#x3D; webdriver.Chrome(chrome_options&#x3D;chrome_options)</span><br><span class="line">for i in range(10):</span><br><span class="line">driver.get(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;)</span><br><span class="line">print(driver.title)</span><br><span class="line">driver.close()</span><br><span class="line">正常的输出就是10个&quot;百度一下，你就知道&quot;</span><br><span class="line">这个方案中，唯一需要注意的就是--no-sandbox参数的添加，root用户需要注意这点，但是添加以后，访问一些不安全的网站时，容易受到威胁，这需要自己权衡。</span><br><span class="line">Xvfb配合使用</span><br><span class="line">In contrast to other display servers, Xvfb performs all graphical operations in virtual memory without showing any screen output.</span><br><span class="line">上面这段话摘自维基百科，简单讲就是，xvfb是一个可以将屏幕的图像输出给放到虚拟内存中的东西，这样一来，在没有GUI的服务器上也能运行一些带图像输出的程序了。</span><br><span class="line">安装xvfb</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install Xvfb</span><br><span class="line">编写test.py文件</span><br><span class="line">关于启动，有两种方法可选</span><br><span class="line">1. xvfb-run python test.py</span><br><span class="line">2. Xvfb :99 &amp; # 给Xvfb开一个指定的显示端口</span><br><span class="line">export DISPLAY&#x3D;:99 # 告诉终端session用哪个端口</span><br><span class="line"></span><br><span class="line">test.py</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line">driver &#x3D; webdriver.Chrome()</span><br><span class="line">for i in range(10):</span><br><span class="line">driver.get(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;)</span><br><span class="line">print(driver.title)</span><br><span class="line">driver.close()</span><br><span class="line"></span><br><span class="line">这里需要注意的就是启动方法中2需要给定监视设备端口，否则chrome是没法启动的，具体表现就是无输出，然后卡住。在安装好Xvfb的前提下，还可以使用xvfb的wrapper进行调用，统一在python文件中启动，管理也更方便，使用方法如下。</span><br><span class="line">pip install pyvirtualdisplay</span><br><span class="line">from selenium import webdriver</span><br><span class="line">from pyvirtualdisplay import Display</span><br><span class="line">display &#x3D; Display(visible&#x3D;0, size&#x3D;(800,600))</span><br><span class="line">display.start()</span><br><span class="line">driver &#x3D; webdriver.Chrome()</span><br><span class="line">for i in range(10):</span><br><span class="line">driver.get(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;)</span><br><span class="line">print(driver.title)</span><br><span class="line">driver.close()</span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「crazyk_wkb」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;wkb342814892&#x2F;article&#x2F;details&#x2F;81591394</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Selenium </tag>
            
            <tag> 开发杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
